<!-- 
Copyright 2023 Dirk Luberth Dijkman Bangert 30 1619GJ Andijk The Netherlands    
The Art of Time Controlled. Visual TimeSlots Schedule.
-->
<html
    lang="en"
>
    <head>
        <meta charset="UTF-8" />
        <title>Telegram WebApp MiniApp Arduino ESP8266, The Art of Time Controlled. Visual TimeSlots Schedule. On/Off Switch Times</title>
     <!--  <script src="https://telegram.org/js/telegram-web-app.js"></script>-->

        <script>
// WebView
(function () {
  var eventHandlers = {};

  var locationHash = '';
  try {
    locationHash = location.hash.toString();
  } catch (e) {}

  var initParams = urlParseHashParams(locationHash);
  var storedParams = sessionStorageGet('initParams');
  if (storedParams) {
    for (var key in storedParams) {
      if (typeof initParams[key] === 'undefined') {
        initParams[key] = storedParams[key];
      }
    }
  }
  sessionStorageSet('initParams', initParams);

  var isIframe = false, iFrameStyle;
  try {
    isIframe = (window.parent != null && window != window.parent);
    if (isIframe) {
      window.addEventListener('message', function (event) {
        if (event.source !== window.parent) return;
        try {
          var dataParsed = JSON.parse(event.data);
        } catch (e) {
          return;
        }
        if (!dataParsed || !dataParsed.eventType) {
          return;
        }
        if (dataParsed.eventType == 'set_custom_style') {
          if (event.origin === 'https://web.telegram.org') {
            iFrameStyle.innerHTML = dataParsed.eventData;
          }
        } else if (dataParsed.eventType == 'reload_iframe') {
          try {
            window.parent.postMessage(JSON.stringify({eventType: 'iframe_will_reload'}), '*');
          } catch (e) {}
          location.reload();
        } else {
          receiveEvent(dataParsed.eventType, dataParsed.eventData);
        }
      });
      iFrameStyle = document.createElement('style');
      document.head.appendChild(iFrameStyle);
      try {
        window.parent.postMessage(JSON.stringify({eventType: 'iframe_ready', eventData: {reload_supported: true}}), '*');
      } catch (e) {}
    }
  } catch (e) {}

  function urlSafeDecode(urlencoded) {
    try {
      urlencoded = urlencoded.replace(/\+/g, '%20');
      return decodeURIComponent(urlencoded);
    } catch (e) {
      return urlencoded;
    }
  }

  function urlParseHashParams(locationHash) {
    locationHash = locationHash.replace(/^#/, '');
    var params = {};
    if (!locationHash.length) {
      return params;
    }
    if (locationHash.indexOf('=') < 0 && locationHash.indexOf('?') < 0) {
      params._path = urlSafeDecode(locationHash);
      return params;
    }
    var qIndex = locationHash.indexOf('?');
    if (qIndex >= 0) {
      var pathParam = locationHash.substr(0, qIndex);
      params._path = urlSafeDecode(pathParam);
      locationHash = locationHash.substr(qIndex + 1);
    }
    var query_params = urlParseQueryString(locationHash);
    for (var k in query_params) {
      params[k] = query_params[k];
    }
    return params;
  }

  function urlParseQueryString(queryString) {
    var params = {};
    if (!queryString.length) {
      return params;
    }
    var queryStringParams = queryString.split('&');
    var i, param, paramName, paramValue;
    for (i = 0; i < queryStringParams.length; i++) {
      param = queryStringParams[i].split('=');
      paramName = urlSafeDecode(param[0]);
      paramValue = param[1] == null ? null : urlSafeDecode(param[1]);
      params[paramName] = paramValue;
    }
    return params;
  }

  // Telegram apps will implement this logic to add service params (e.g. tgShareScoreUrl) to game URL
  function urlAppendHashParams(url, addHash) {
    // url looks like 'https://game.com/path?query=1#hash'
    // addHash looks like 'tgShareScoreUrl=' + encodeURIComponent('tgb://share_game_score?hash=very_long_hash123')

    var ind = url.indexOf('#');
    if (ind < 0) {
      // https://game.com/path -> https://game.com/path#tgShareScoreUrl=etc
      return url + '#' + addHash;
    }
    var curHash = url.substr(ind + 1);
    if (curHash.indexOf('=') >= 0 || curHash.indexOf('?') >= 0) {
      // https://game.com/#hash=1 -> https://game.com/#hash=1&tgShareScoreUrl=etc
      // https://game.com/#path?query -> https://game.com/#path?query&tgShareScoreUrl=etc
      return url + '&' + addHash;
    }
    // https://game.com/#hash -> https://game.com/#hash?tgShareScoreUrl=etc
    if (curHash.length > 0) {
      return url + '?' + addHash;
    }
    // https://game.com/# -> https://game.com/#tgShareScoreUrl=etc
    return url + addHash;
  }

  function postEvent(eventType, callback, eventData) {
    if (!callback) {
      callback = function () {};
    }
    if (eventData === undefined) {
      eventData = '';
    }
    console.log('[Telegram.WebView] > postEvent', eventType, eventData);

    if (window.TelegramWebviewProxy !== undefined) {
      TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));
      callback();
    }
    else if (window.external && 'notify' in window.external) {
      window.external.notify(JSON.stringify({eventType: eventType, eventData: eventData}));
      callback();
    }
    else if (isIframe) {
      try {
        var trustedTarget = 'https://web.telegram.org';
        // For now we don't restrict target, for testing purposes
        trustedTarget = '*';
        window.parent.postMessage(JSON.stringify({eventType: eventType, eventData: eventData}), trustedTarget);
        callback();
      } catch (e) {
        callback(e);
      }
    }
    else {
      callback({notAvailable: true});
    }
  };

  function receiveEvent(eventType, eventData) {
    console.log('[Telegram.WebView] < receiveEvent', eventType, eventData);
    callEventCallbacks(eventType, function(callback) {
      callback(eventType, eventData);
    });
  }

  function callEventCallbacks(eventType, func) {
    var curEventHandlers = eventHandlers[eventType];
    if (curEventHandlers === undefined ||
        !curEventHandlers.length) {
      return;
    }
    for (var i = 0; i < curEventHandlers.length; i++) {
      try {
        func(curEventHandlers[i]);
      } catch (e) {}
    }
  }

  function onEvent(eventType, callback) {
    if (eventHandlers[eventType] === undefined) {
      eventHandlers[eventType] = [];
    }
    var index = eventHandlers[eventType].indexOf(callback);
    if (index === -1) {
      eventHandlers[eventType].push(callback);
    }
  };

  function offEvent(eventType, callback) {
    if (eventHandlers[eventType] === undefined) {
      return;
    }
    var index = eventHandlers[eventType].indexOf(callback);
    if (index === -1) {
      return;
    }
    eventHandlers[eventType].splice(index, 1);
  };

  function openProtoUrl(url) {
    if (!url.match(/^(web\+)?tgb?:\/\/./)) {
      return false;
    }
    var useIframe = navigator.userAgent.match(/iOS|iPhone OS|iPhone|iPod|iPad/i) ? true : false;
    if (useIframe) {
      var iframeContEl = document.getElementById('tgme_frame_cont') || document.body;
      var iframeEl = document.createElement('iframe');
      iframeContEl.appendChild(iframeEl);
      var pageHidden = false;
      var enableHidden = function () {
        pageHidden = true;
      };
      window.addEventListener('pagehide', enableHidden, false);
      window.addEventListener('blur', enableHidden, false);
      if (iframeEl !== null) {
        iframeEl.src = url;
      }
      setTimeout(function() {
        if (!pageHidden) {
          window.location = url;
        }
        window.removeEventListener('pagehide', enableHidden, false);
        window.removeEventListener('blur', enableHidden, false);
      }, 2000);
    }
    else {
      window.location = url;
    }
    return true;
  }

  function sessionStorageSet(key, value) {
    try {
      window.sessionStorage.setItem('__telegram__' + key, JSON.stringify(value));
      return true;
    } catch(e) {}
    return false;
  }
  function sessionStorageGet(key) {
    try {
      return JSON.parse(window.sessionStorage.getItem('__telegram__' + key));
    } catch(e) {}
    return null;
  }

  if (!window.Telegram) {
    window.Telegram = {};
  }
  window.Telegram.WebView = {
    initParams: initParams,
    isIframe: isIframe,
    onEvent: onEvent,
    offEvent: offEvent,
    postEvent: postEvent,
    receiveEvent: receiveEvent,
    callEventCallbacks: callEventCallbacks
  };

  window.Telegram.Utils = {
    urlSafeDecode: urlSafeDecode,
    urlParseQueryString: urlParseQueryString,
    urlParseHashParams: urlParseHashParams,
    urlAppendHashParams: urlAppendHashParams,
    sessionStorageSet: sessionStorageSet,
    sessionStorageGet: sessionStorageGet
  };

  // For Windows Phone app
  window.TelegramGameProxy_receiveEvent = receiveEvent;

  // App backward compatibility
  window.TelegramGameProxy = {
    receiveEvent: receiveEvent
  };
})();

// WebApp
(function () {
  var Utils = window.Telegram.Utils;
  var WebView = window.Telegram.WebView;
  var initParams = WebView.initParams;
  var isIframe = WebView.isIframe;

  var WebApp = {};
  var webAppInitData = '', webAppInitDataUnsafe = {};
  var themeParams = {}, colorScheme = 'light';
  var webAppVersion = '6.0';
  var webAppPlatform = 'unknown';

  if (initParams.tgWebAppData && initParams.tgWebAppData.length) {
    webAppInitData = initParams.tgWebAppData;
    webAppInitDataUnsafe = Utils.urlParseQueryString(webAppInitData);
    for (var key in webAppInitDataUnsafe) {
      var val = webAppInitDataUnsafe[key];
      try {
        if (val.substr(0, 1) == '{' && val.substr(-1) == '}' ||
            val.substr(0, 1) == '[' && val.substr(-1) == ']') {
          webAppInitDataUnsafe[key] = JSON.parse(val);
        }
      } catch (e) {}
    }
  }
  if (initParams.tgWebAppThemeParams && initParams.tgWebAppThemeParams.length) {
    var themeParamsRaw = initParams.tgWebAppThemeParams;
    try {
      var theme_params = JSON.parse(themeParamsRaw);
      if (theme_params) {
        setThemeParams(theme_params);
      }
    } catch (e) {}
  }
  var theme_params = Utils.sessionStorageGet('themeParams');
  if (theme_params) {
    setThemeParams(theme_params);
  }
  if (initParams.tgWebAppVersion) {
    webAppVersion = initParams.tgWebAppVersion;
  }
  if (initParams.tgWebAppPlatform) {
    webAppPlatform = initParams.tgWebAppPlatform;
  }

  function onThemeChanged(eventType, eventData) {
    if (eventData.theme_params) {
      setThemeParams(eventData.theme_params);
      window.Telegram.WebApp.MainButton.setParams({});
      updateBackgroundColor();
      receiveWebViewEvent('themeChanged');
    }
  }

  var lastWindowHeight = window.innerHeight;
  function onViewportChanged(eventType, eventData) {
    if (eventData.height) {
      window.removeEventListener('resize', onWindowResize);
      setViewportHeight(eventData);
    }
  }

  function onWindowResize(e) {
    if (lastWindowHeight != window.innerHeight) {
      lastWindowHeight = window.innerHeight;
      receiveWebViewEvent('viewportChanged', {
        isStateStable: true
      });
    }
  }

  function linkHandler(e) {
    if (e.metaKey || e.ctrlKey) return;
    var el = e.target;
    while (el.tagName != 'A' && el.parentNode) {
      el = el.parentNode;
    }
    if (el.tagName == 'A' &&
        el.target != '_blank' &&
        (el.protocol == 'http:' || el.protocol == 'https:') &&
        el.hostname == 't.me') {
      WebApp.openTgLink(el.href);
      e.preventDefault();
    }
  }

  function strTrim(str) {
    return str.toString().replace(/^\s+|\s+$/g, '');
  }

  function receiveWebViewEvent(eventType) {
    var args = Array.prototype.slice.call(arguments);
    eventType = args.shift();
    WebView.callEventCallbacks('webview:' + eventType, function(callback) {
      callback.apply(WebApp, args);
    });
  }

  function onWebViewEvent(eventType, callback) {
    WebView.onEvent('webview:' + eventType, callback);
  };

  function offWebViewEvent(eventType, callback) {
    WebView.offEvent('webview:' + eventType, callback);
  };

  function setCssProperty(name, value) {
    var root = document.documentElement;
    if (root && root.style && root.style.setProperty) {
      root.style.setProperty('--tg-' + name, value);
    }
  }

  function setThemeParams(theme_params) {
    // temp iOS fix
    if (theme_params.bg_color == '#1c1c1d' &&
        theme_params.bg_color == theme_params.secondary_bg_color) {
      theme_params.secondary_bg_color = '#2c2c2e';
    }
    var color;
    for (var key in theme_params) {
      if (color = parseColorToHex(theme_params[key])) {
        themeParams[key] = color;
        if (key == 'bg_color') {
          colorScheme = isColorDark(color) ? 'dark' : 'light'
          setCssProperty('color-scheme', colorScheme);
        }
        key = 'theme-' + key.split('_').join('-');
        setCssProperty(key, color);
      }
    }
    Utils.sessionStorageSet('themeParams', themeParams);
  }

  var webAppCallbacks = {};
  function generateCallbackId(len) {
    var tries = 100;
    while (--tries) {
      var id = '', chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', chars_len = chars.length;
      for (var i = 0; i < len; i++) {
        id += chars[Math.floor(Math.random() * chars_len)];
      }
      if (!webAppCallbacks[id]) {
        webAppCallbacks[id] = {};
        return id;
      }
    }
    throw Error('WebAppCallbackIdGenerateFailed');
  }

  var viewportHeight = false, viewportStableHeight = false, isExpanded = true;
  function setViewportHeight(data) {
    if (typeof data !== 'undefined') {
      isExpanded = !!data.is_expanded;
      viewportHeight = data.height;
      if (data.is_state_stable) {
        viewportStableHeight = data.height;
      }
      receiveWebViewEvent('viewportChanged', {
        isStateStable: !!data.is_state_stable
      });
    }
    var height, stable_height;
    if (viewportHeight !== false) {
      height = (viewportHeight - mainButtonHeight) + 'px';
    } else {
      height = mainButtonHeight ? 'calc(100vh - ' + mainButtonHeight + 'px)' : '100vh';
    }
    if (viewportStableHeight !== false) {
      stable_height = (viewportStableHeight - mainButtonHeight) + 'px';
    } else {
      stable_height = mainButtonHeight ? 'calc(100vh - ' + mainButtonHeight + 'px)' : '100vh';
    }
    setCssProperty('viewport-height', height);
    setCssProperty('viewport-stable-height', stable_height);
  }

  var isClosingConfirmationEnabled = false;
  function setClosingConfirmation(need_confirmation) {
    if (!versionAtLeast('6.2')) {
      console.warn('[Telegram.WebApp] Closing confirmation is not supported in version ' + webAppVersion);
      return;
    }
    isClosingConfirmationEnabled = !!need_confirmation;
    WebView.postEvent('web_app_setup_closing_behavior', false, {need_confirmation: isClosingConfirmationEnabled});
  }

  var headerColorKey = 'bg_color', headerColor = null;
  function getHeaderColor() {
    if (headerColorKey == 'secondary_bg_color') {
      return themeParams.secondary_bg_color;
    } else if (headerColorKey == 'bg_color') {
      return themeParams.bg_color;
    }
    return headerColor;
  }
  function setHeaderColor(color) {
    if (!versionAtLeast('6.1')) {
      console.warn('[Telegram.WebApp] Header color is not supported in version ' + webAppVersion);
      return;
    }
    if (!versionAtLeast('6.9')) {
      if (themeParams.bg_color &&
          themeParams.bg_color == color) {
        color = 'bg_color';
      } else if (themeParams.secondary_bg_color &&
                 themeParams.secondary_bg_color == color) {
        color = 'secondary_bg_color';
      }
    }
    var head_color = null, color_key = null;
    if (color == 'bg_color' || color == 'secondary_bg_color') {
      color_key = color;
    } else if (versionAtLeast('6.9')) {
      head_color = parseColorToHex(color);
      if (!head_color) {
        console.error('[Telegram.WebApp] Header color format is invalid', color);
        throw Error('WebAppHeaderColorInvalid');
      }
    }
    if (!versionAtLeast('6.9') &&
        color_key != 'bg_color' &&
        color_key != 'secondary_bg_color') {
      console.error('[Telegram.WebApp] Header color key should be one of Telegram.WebApp.themeParams.bg_color, Telegram.WebApp.themeParams.secondary_bg_color, \'bg_color\', \'secondary_bg_color\'', color);
      throw Error('WebAppHeaderColorKeyInvalid');
    }
    headerColorKey = color_key;
    headerColor = head_color;
    updateHeaderColor();
  }
  var appHeaderColorKey = null, appHeaderColor = null;
  function updateHeaderColor() {
    if (appHeaderColorKey != headerColorKey ||
        appHeaderColor != headerColor) {
      appHeaderColorKey = headerColorKey;
      appHeaderColor = headerColor;
      if (appHeaderColor) {
        WebView.postEvent('web_app_set_header_color', false, {color: headerColor});
      } else {
        WebView.postEvent('web_app_set_header_color', false, {color_key: headerColorKey});
      }
    }
  }

  var backgroundColor = 'bg_color';
  function getBackgroundColor() {
    if (backgroundColor == 'secondary_bg_color') {
      return themeParams.secondary_bg_color;
    } else if (backgroundColor == 'bg_color') {
      return themeParams.bg_color;
    }
    return backgroundColor;
  }
  function setBackgroundColor(color) {
    if (!versionAtLeast('6.1')) {
      console.warn('[Telegram.WebApp] Background color is not supported in version ' + webAppVersion);
      return;
    }
    var bg_color;
    if (color == 'bg_color' || color == 'secondary_bg_color') {
      bg_color = color;
    } else {
      bg_color = parseColorToHex(color);
      if (!bg_color) {
        console.error('[Telegram.WebApp] Background color format is invalid', color);
        throw Error('WebAppBackgroundColorInvalid');
      }
    }
    backgroundColor = bg_color;
    updateBackgroundColor();
  }
  var appBackgroundColor = null;
  function updateBackgroundColor() {
    var color = getBackgroundColor();
    if (appBackgroundColor != color) {
      appBackgroundColor = color;
      WebView.postEvent('web_app_set_background_color', false, {color: color});
    }
  }


  function parseColorToHex(color) {
    color += '';
    var match;
    if (match = /^\s*#([0-9a-f]{6})\s*$/i.exec(color)) {
      return '#' + match[1].toLowerCase();
    }
    else if (match = /^\s*#([0-9a-f])([0-9a-f])([0-9a-f])\s*$/i.exec(color)) {
      return ('#' + match[1] + match[1] + match[2] + match[2] + match[3] + match[3]).toLowerCase();
    }
    else if (match = /^\s*rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)\s*$/.exec(color)) {
      var r = parseInt(match[1]), g = parseInt(match[2]), b = parseInt(match[3]);
      r = (r < 16 ? '0' : '') + r.toString(16);
      g = (g < 16 ? '0' : '') + g.toString(16);
      b = (b < 16 ? '0' : '') + b.toString(16);
      return '#' + r + g + b;
    }
    return false;
  }

  function isColorDark(rgb) {
    rgb = rgb.replace(/[\s#]/g, '');
    if (rgb.length == 3) {
      rgb = rgb[0] + rgb[0] + rgb[1] + rgb[1] + rgb[2] + rgb[2];
    }
    var r = parseInt(rgb.substr(0, 2), 16);
    var g = parseInt(rgb.substr(2, 2), 16);
    var b = parseInt(rgb.substr(4, 2), 16);
    var hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));
    return hsp < 120;
  }

  function versionCompare(v1, v2) {
    if (typeof v1 !== 'string') v1 = '';
    if (typeof v2 !== 'string') v2 = '';
    v1 = v1.replace(/^\s+|\s+$/g, '').split('.');
    v2 = v2.replace(/^\s+|\s+$/g, '').split('.');
    var a = Math.max(v1.length, v2.length), i, p1, p2;
    for (i = 0; i < a; i++) {
      p1 = parseInt(v1[i]) || 0;
      p2 = parseInt(v2[i]) || 0;
      if (p1 == p2) continue;
      if (p1 > p2) return 1;
      return -1;
    }
    return 0;
  }

  function versionAtLeast(ver) {
    return versionCompare(webAppVersion, ver) >= 0;
  }

  function byteLength(str) {
    if (window.Blob) {
      try { return new Blob([str]).size; } catch (e) {}
    }
    var s = str.length;
    for (var i=str.length-1; i>=0; i--) {
      var code = str.charCodeAt(i);
      if (code > 0x7f && code <= 0x7ff) s++;
      else if (code > 0x7ff && code <= 0xffff) s+=2;
      if (code >= 0xdc00 && code <= 0xdfff) i--;
    }
    return s;
  }

  var BackButton = (function() {
    var isVisible = false;

    var backButton = {};
    Object.defineProperty(backButton, 'isVisible', {
      set: function(val){ setParams({is_visible: val}); },
      get: function(){ return isVisible; },
      enumerable: true
    });

    var curButtonState = null;

    WebView.onEvent('back_button_pressed', onBackButtonPressed);

    function onBackButtonPressed() {
      receiveWebViewEvent('backButtonClicked');
    }

    function buttonParams() {
      return {is_visible: isVisible};
    }

    function buttonState(btn_params) {
      if (typeof btn_params === 'undefined') {
        btn_params = buttonParams();
      }
      return JSON.stringify(btn_params);
    }

    function buttonCheckVersion() {
      if (!versionAtLeast('6.1')) {
        console.warn('[Telegram.WebApp] BackButton is not supported in version ' + webAppVersion);
        return false;
      }
      return true;
    }

    function updateButton() {
      var btn_params = buttonParams();
      var btn_state = buttonState(btn_params);
      if (curButtonState === btn_state) {
        return;
      }
      curButtonState = btn_state;
      WebView.postEvent('web_app_setup_back_button', false, btn_params);
    }

    function setParams(params) {
      if (!buttonCheckVersion()) {
        return backButton;
      }
      if (typeof params.is_visible !== 'undefined') {
        isVisible = !!params.is_visible;
      }
      updateButton();
      return backButton;
    }

    backButton.onClick = function(callback) {
      if (buttonCheckVersion()) {
        onWebViewEvent('backButtonClicked', callback);
      }
      return backButton;
    };
    backButton.offClick = function(callback) {
      if (buttonCheckVersion()) {
        offWebViewEvent('backButtonClicked', callback);
      }
      return backButton;
    };
    backButton.show = function() {
      return setParams({is_visible: true});
    };
    backButton.hide = function() {
      return setParams({is_visible: false});
    };
    return backButton;
  })();

  var mainButtonHeight = 0;
  var MainButton = (function() {
    var isVisible = false;
    var isActive = true;
    var isProgressVisible = false;
    var buttonText = 'CONTINUE';
    var buttonColor = false;
    var buttonTextColor = false;

    var mainButton = {};
    Object.defineProperty(mainButton, 'text', {
      set: function(val){ mainButton.setParams({text: val}); },
      get: function(){ return buttonText; },
      enumerable: true
    });
    Object.defineProperty(mainButton, 'color', {
      set: function(val){ mainButton.setParams({color: val}); },
      get: function(){ return buttonColor || themeParams.button_color || '#2481cc'; },
      enumerable: true
    });
    Object.defineProperty(mainButton, 'textColor', {
      set: function(val){ mainButton.setParams({text_color: val}); },
      get: function(){ return buttonTextColor || themeParams.button_text_color || '#ffffff'; },
      enumerable: true
    });
    Object.defineProperty(mainButton, 'isVisible', {
      set: function(val){ mainButton.setParams({is_visible: val}); },
      get: function(){ return isVisible; },
      enumerable: true
    });
    Object.defineProperty(mainButton, 'isProgressVisible', {
      get: function(){ return isProgressVisible; },
      enumerable: true
    });
    Object.defineProperty(mainButton, 'isActive', {
      set: function(val){ mainButton.setParams({is_active: val}); },
      get: function(){ return isActive; },
      enumerable: true
    });

    var curButtonState = null;

    WebView.onEvent('main_button_pressed', onMainButtonPressed);

    var debugBtn = null, debugBtnStyle = {};
    if (initParams.tgWebAppDebug) {
      debugBtn = document.createElement('tg-main-button');
      debugBtnStyle = {
        font: '600 14px/18px sans-serif',
        display: 'none',
        width: '100%',
        height: '48px',
        borderRadius: '0',
        background: 'no-repeat right center',
        position: 'fixed',
        left: '0',
        right: '0',
        bottom: '0',
        margin: '0',
        padding: '15px 20px',
        textAlign: 'center',
        boxSizing: 'border-box',
        zIndex: '10000'
      };
      for (var k in debugBtnStyle) {
        debugBtn.style[k] = debugBtnStyle[k];
      }
      document.addEventListener('DOMContentLoaded', function onDomLoaded(event) {
        document.removeEventListener('DOMContentLoaded', onDomLoaded);
        document.body.appendChild(debugBtn);
        debugBtn.addEventListener('click', onMainButtonPressed, false);
      });
    }

    function onMainButtonPressed() {
      if (isActive) {
        receiveWebViewEvent('mainButtonClicked');
      }
    }

    function buttonParams() {
      var color = mainButton.color;
      var text_color = mainButton.textColor;
      return isVisible ? {
        is_visible: true,
        is_active: isActive,
        is_progress_visible: isProgressVisible,
        text: buttonText,
        color: color,
        text_color: text_color
      } : {is_visible: false};
    }

    function buttonState(btn_params) {
      if (typeof btn_params === 'undefined') {
        btn_params = buttonParams();
      }
      return JSON.stringify(btn_params);
    }

    function updateButton() {
      var btn_params = buttonParams();
      var btn_state = buttonState(btn_params);
      if (curButtonState === btn_state) {
        return;
      }
      curButtonState = btn_state;
      WebView.postEvent('web_app_setup_main_button', false, btn_params);
      if (initParams.tgWebAppDebug) {
        updateDebugButton(btn_params);
      }
    }

    function updateDebugButton(btn_params) {
      if (btn_params.is_visible) {
        debugBtn.style.display = 'block';
        mainButtonHeight = 48;

        debugBtn.style.opacity = btn_params.is_active ? '1' : '0.8';
        debugBtn.style.cursor = btn_params.is_active ? 'pointer' : 'auto';
        debugBtn.disabled = !btn_params.is_active;
        debugBtn.innerText = btn_params.text;
        debugBtn.style.backgroundImage = btn_params.is_progress_visible ? "url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20viewport%3D%220%200%2048%2048%22%20width%3D%2248px%22%20height%3D%2248px%22%3E%3Ccircle%20cx%3D%2250%25%22%20cy%3D%2250%25%22%20stroke%3D%22%23fff%22%20stroke-width%3D%222.25%22%20stroke-linecap%3D%22round%22%20fill%3D%22none%22%20stroke-dashoffset%3D%22106%22%20r%3D%229%22%20stroke-dasharray%3D%2256.52%22%20rotate%3D%22-90%22%3E%3Canimate%20attributeName%3D%22stroke-dashoffset%22%20attributeType%3D%22XML%22%20dur%3D%22360s%22%20from%3D%220%22%20to%3D%2212500%22%20repeatCount%3D%22indefinite%22%3E%3C%2Fanimate%3E%3CanimateTransform%20attributeName%3D%22transform%22%20attributeType%3D%22XML%22%20type%3D%22rotate%22%20dur%3D%221s%22%20from%3D%22-90%2024%2024%22%20to%3D%22630%2024%2024%22%20repeatCount%3D%22indefinite%22%3E%3C%2FanimateTransform%3E%3C%2Fcircle%3E%3C%2Fsvg%3E')" : 'none';
        debugBtn.style.backgroundColor = btn_params.color;
        debugBtn.style.color = btn_params.text_color;
      } else {
        debugBtn.style.display = 'none';
        mainButtonHeight = 0;
      }
      if (document.documentElement) {
        document.documentElement.style.boxSizing = 'border-box';
        document.documentElement.style.paddingBottom = mainButtonHeight + 'px';
      }
      setViewportHeight();
    }

    function setParams(params) {
      if (typeof params.text !== 'undefined') {
        var text = strTrim(params.text);
        if (!text.length) {
          console.error('[Telegram.WebApp] Main button text is required', params.text);
          throw Error('WebAppMainButtonParamInvalid');
        }
        if (text.length > 64) {
          console.error('[Telegram.WebApp] Main button text is too long', text);
          throw Error('WebAppMainButtonParamInvalid');
        }
        buttonText = text;
      }
      if (typeof params.color !== 'undefined') {
        if (params.color === false ||
            params.color === null) {
          buttonColor = false;
        } else {
          var color = parseColorToHex(params.color);
          if (!color) {
            console.error('[Telegram.WebApp] Main button color format is invalid', params.color);
            throw Error('WebAppMainButtonParamInvalid');
          }
          buttonColor = color;
        }
      }
      if (typeof params.text_color !== 'undefined') {
        if (params.text_color === false ||
            params.text_color === null) {
          buttonTextColor = false;
        } else {
          var text_color = parseColorToHex(params.text_color);
          if (!text_color) {
            console.error('[Telegram.WebApp] Main button text color format is invalid', params.text_color);
            throw Error('WebAppMainButtonParamInvalid');
          }
          buttonTextColor = text_color;
        }
      }
      if (typeof params.is_visible !== 'undefined') {
        if (params.is_visible &&
            !mainButton.text.length) {
          console.error('[Telegram.WebApp] Main button text is required');
          throw Error('WebAppMainButtonParamInvalid');
        }
        isVisible = !!params.is_visible;
      }
      if (typeof params.is_active !== 'undefined') {
        isActive = !!params.is_active;
      }
      updateButton();
      return mainButton;
    }

    mainButton.setText = function(text) {
      return mainButton.setParams({text: text});
    };
    mainButton.onClick = function(callback) {
      onWebViewEvent('mainButtonClicked', callback);
      return mainButton;
    };
    mainButton.offClick = function(callback) {
      offWebViewEvent('mainButtonClicked', callback);
      return mainButton;
    };
    mainButton.show = function() {
      return mainButton.setParams({is_visible: true});
    };
    mainButton.hide = function() {
      return mainButton.setParams({is_visible: false});
    };
    mainButton.enable = function() {
      return mainButton.setParams({is_active: true});
    };
    mainButton.disable = function() {
      return mainButton.setParams({is_active: false});
    };
    mainButton.showProgress = function(leaveActive) {
      isActive = !!leaveActive;
      isProgressVisible = true;
      updateButton();
      return mainButton;
    };
    mainButton.hideProgress = function() {
      if (!mainButton.isActive) {
        isActive = true;
      }
      isProgressVisible = false;
      updateButton();
      return mainButton;
    }
    mainButton.setParams = setParams;
    return mainButton;
  })();

  var SettingsButton = (function() {
    var isVisible = false;

    var settingsButton = {};
    Object.defineProperty(settingsButton, 'isVisible', {
      set: function(val){ setParams({is_visible: val}); },
      get: function(){ return isVisible; },
      enumerable: true
    });

    var curButtonState = null;

    WebView.onEvent('settings_button_pressed', onSettingsButtonPressed);

    function onSettingsButtonPressed() {
      receiveWebViewEvent('settingsButtonClicked');
    }

    function buttonParams() {
      return {is_visible: isVisible};
    }

    function buttonState(btn_params) {
      if (typeof btn_params === 'undefined') {
        btn_params = buttonParams();
      }
      return JSON.stringify(btn_params);
    }

    function buttonCheckVersion() {
      if (!versionAtLeast('6.10')) {
        console.warn('[Telegram.WebApp] SettingsButton is not supported in version ' + webAppVersion);
        return false;
      }
      return true;
    }

    function updateButton() {
      var btn_params = buttonParams();
      var btn_state = buttonState(btn_params);
      if (curButtonState === btn_state) {
        return;
      }
      curButtonState = btn_state;
      WebView.postEvent('web_app_setup_settings_button', false, btn_params);
    }

    function setParams(params) {
      if (!buttonCheckVersion()) {
        return settingsButton;
      }
      if (typeof params.is_visible !== 'undefined') {
        isVisible = !!params.is_visible;
      }
      updateButton();
      return settingsButton;
    }

    settingsButton.onClick = function(callback) {
      if (buttonCheckVersion()) {
        onWebViewEvent('settingsButtonClicked', callback);
      }
      return settingsButton;
    };
    settingsButton.offClick = function(callback) {
      if (buttonCheckVersion()) {
        offWebViewEvent('settingsButtonClicked', callback);
      }
      return settingsButton;
    };
    settingsButton.show = function() {
      return setParams({is_visible: true});
    };
    settingsButton.hide = function() {
      return setParams({is_visible: false});
    };
    return settingsButton;
  })();

  var HapticFeedback = (function() {
    var hapticFeedback = {};

    function triggerFeedback(params) {
      if (!versionAtLeast('6.1')) {
        console.warn('[Telegram.WebApp] HapticFeedback is not supported in version ' + webAppVersion);
        return hapticFeedback;
      }
      if (params.type == 'impact') {
        if (params.impact_style != 'light' &&
            params.impact_style != 'medium' &&
            params.impact_style != 'heavy' &&
            params.impact_style != 'rigid' &&
            params.impact_style != 'soft') {
          console.error('[Telegram.WebApp] Haptic impact style is invalid', params.impact_style);
          throw Error('WebAppHapticImpactStyleInvalid');
        }
      } else if (params.type == 'notification') {
        if (params.notification_type != 'error' &&
            params.notification_type != 'success' &&
            params.notification_type != 'warning') {
          console.error('[Telegram.WebApp] Haptic notification type is invalid', params.notification_type);
          throw Error('WebAppHapticNotificationTypeInvalid');
        }
      } else if (params.type == 'selection_change') {
        // no params needed
      } else {
        console.error('[Telegram.WebApp] Haptic feedback type is invalid', params.type);
        throw Error('WebAppHapticFeedbackTypeInvalid');
      }
      WebView.postEvent('web_app_trigger_haptic_feedback', false, params);
      return hapticFeedback;
    }

    hapticFeedback.impactOccurred = function(style) {
      return triggerFeedback({type: 'impact', impact_style: style});
    };
    hapticFeedback.notificationOccurred = function(type) {
      return triggerFeedback({type: 'notification', notification_type: type});
    };
    hapticFeedback.selectionChanged = function() {
      return triggerFeedback({type: 'selection_change'});
    };
    return hapticFeedback;
  })();

  var CloudStorage = (function() {
    var cloudStorage = {};

    function invokeStorageMethod(method, params, callback) {
      if (!versionAtLeast('6.9')) {
        console.error('[Telegram.WebApp] CloudStorage is not supported in version ' + webAppVersion);
        throw Error('WebAppMethodUnsupported');
      }
      invokeCustomMethod(method, params, callback);
      return cloudStorage;
    }

    cloudStorage.setItem = function(key, value, callback) {
      return invokeStorageMethod('saveStorageValue', {key: key, value: value}, callback);
    };
    cloudStorage.getItem = function(key, callback) {
      return cloudStorage.getItems([key], callback ? function(err, res) {
        if (err) callback(err);
        else callback(null, res[key]);
      } : null);
    };
    cloudStorage.getItems = function(keys, callback) {
      return invokeStorageMethod('getStorageValues', {keys: keys}, callback);
    };
    cloudStorage.removeItem = function(key, callback) {
      return cloudStorage.removeItems([key], callback);
    };
    cloudStorage.removeItems = function(keys, callback) {
      return invokeStorageMethod('deleteStorageValues', {keys: keys}, callback);
    };
    cloudStorage.getKeys = function(callback) {
      return invokeStorageMethod('getStorageKeys', {}, callback);
    };
    return cloudStorage;
  })();

  var BiometricManager = (function() {
    var isInited = false;
    var isBiometricAvailable = false;
    var biometricType = 'unknown';
    var isAccessRequested = false;
    var isAccessGranted = false;
    var isBiometricTokenSaved = false;
    var deviceId = '';

    var biometricManager = {};
    Object.defineProperty(biometricManager, 'isInited', {
      get: function(){ return isInited; },
      enumerable: true
    });
    Object.defineProperty(biometricManager, 'isBiometricAvailable', {
      get: function(){ return isInited && isBiometricAvailable; },
      enumerable: true
    });
    Object.defineProperty(biometricManager, 'biometricType', {
      get: function(){ return biometricType || 'unknown'; },
      enumerable: true
    });
    Object.defineProperty(biometricManager, 'isAccessRequested', {
      get: function(){ return isAccessRequested; },
      enumerable: true
    });
    Object.defineProperty(biometricManager, 'isAccessGranted', {
      get: function(){ return isAccessRequested && isAccessGranted; },
      enumerable: true
    });
    Object.defineProperty(biometricManager, 'isBiometricTokenSaved', {
      get: function(){ return isBiometricTokenSaved; },
      enumerable: true
    });
    Object.defineProperty(biometricManager, 'deviceId', {
      get: function(){ return deviceId || ''; },
      enumerable: true
    });

    var initRequestState = {callbacks: []};
    var accessRequestState = false;
    var authRequestState = false;
    var tokenRequestState = false;

    WebView.onEvent('biometry_info_received',  onBiometryInfoReceived);
    WebView.onEvent('biometry_auth_requested', onBiometryAuthRequested);
    WebView.onEvent('biometry_token_updated',  onBiometryTokenUpdated);

    function onBiometryInfoReceived(eventType, eventData) {
      isInited = true;
      if (eventData.available) {
        isBiometricAvailable = true;
        biometricType = eventData.type || 'unknown';
        if (eventData.access_requested) {
          isAccessRequested = true;
          isAccessGranted = !!eventData.access_granted;
          isBiometricTokenSaved = !!eventData.token_saved;
        } else {
          isAccessRequested = false;
          isAccessGranted = false;
          isBiometricTokenSaved = false;
        }
      } else {
        isBiometricAvailable = false;
        biometricType = 'unknown';
        isAccessRequested = false;
        isAccessGranted = false;
        isBiometricTokenSaved = false;
      }
      deviceId = eventData.device_id || '';

      if (initRequestState.callbacks.length > 0) {
        for (var i = 0; i < initRequestState.callbacks.length; i++) {
          var callback = initRequestState.callbacks[i];
          callback();
        }
      }
      if (accessRequestState) {
        var state = accessRequestState;
        accessRequestState = false;
        if (state.callback) {
          state.callback(isAccessGranted);
        }
      }
      receiveWebViewEvent('biometricManagerUpdated');
    }
    function onBiometryAuthRequested(eventType, eventData) {
      var isAuthenticated = (eventData.status == 'authorized'),
          biometricToken = eventData.token || '';
      if (authRequestState) {
        var state = authRequestState;
        authRequestState = false;
        if (state.callback) {
          state.callback(isAuthenticated, isAuthenticated ? biometricToken : null);
        }
      }
      receiveWebViewEvent('biometricAuthRequested', isAuthenticated ? {
        isAuthenticated: true,
        biometricToken: biometricToken
      } : {
        isAuthenticated: false
      });
    }
    function onBiometryTokenUpdated(eventType, eventData) {
      var applied = false;
      if (isBiometricAvailable &&
          isAccessRequested) {
        if (eventData.status == 'updated') {
          isBiometricTokenSaved = true;
          applied = true;
        }
        else if (eventData.status == 'removed') {
          isBiometricTokenSaved = false;
          applied = true;
        }
      }
      if (tokenRequestState) {
        var state = tokenRequestState;
        tokenRequestState = false;
        if (state.callback) {
          state.callback(applied);
        }
      }
      receiveWebViewEvent('biometricTokenUpdated', {
        isUpdated: applied
      });
    }

    function checkVersion() {
      if (!versionAtLeast('7.2')) {
        console.warn('[Telegram.WebApp] BiometricManager is not supported in version ' + webAppVersion);
        return false;
      }
      return true;
    }

    function checkInit() {
      if (!isInited) {
        console.error('[Telegram.WebApp] BiometricManager should be inited before using.');
        throw Error('WebAppBiometricManagerNotInited');
      }
      return true;
    }

    biometricManager.init = function(callback) {
      if (!checkVersion()) {
        return biometricManager;
      }
      if (isInited) {
        return biometricManager;
      }
      if (callback) {
        initRequestState.callbacks.push(callback);
      }
      WebView.postEvent('web_app_biometry_get_info', false);
      return biometricManager;
    };
    biometricManager.requestAccess = function(params, callback) {
      if (!checkVersion()) {
        return biometricManager;
      }
      checkInit();
      if (!isBiometricAvailable) {
        console.error('[Telegram.WebApp] Biometrics is not available on this device.');
        throw Error('WebAppBiometricManagerBiometricsNotAvailable');
      }
      if (accessRequestState) {
        console.error('[Telegram.WebApp] Access is already requested');
        throw Error('WebAppBiometricManagerAccessRequested');
      }
      var popup_params = {};
      if (typeof params.reason !== 'undefined') {
        var reason = strTrim(params.reason);
        if (reason.length > 128) {
          console.error('[Telegram.WebApp] Biometric reason is too long', reason);
          throw Error('WebAppBiometricRequestAccessParamInvalid');
        }
        if (reason.length > 0) {
          popup_params.reason = reason;
        }
      }

      accessRequestState = {
        callback: callback
      };
      WebView.postEvent('web_app_biometry_request_access', false, popup_params);
      return biometricManager;
    };
    biometricManager.authenticate = function(params, callback) {
      if (!checkVersion()) {
        return biometricManager;
      }
      checkInit();
      if (!isBiometricAvailable) {
        console.error('[Telegram.WebApp] Biometrics is not available on this device.');
        throw Error('WebAppBiometricManagerBiometricsNotAvailable');
      }
      if (!isAccessGranted) {
        console.error('[Telegram.WebApp] Biometric access was not granted by the user.');
        throw Error('WebAppBiometricManagerBiometricAccessNotGranted');
      }
      if (authRequestState) {
        console.error('[Telegram.WebApp] Authentication request is already in progress.');
        throw Error('WebAppBiometricManagerAuthenticationRequested');
      }
      var popup_params = {};
      if (typeof params.reason !== 'undefined') {
        var reason = strTrim(params.reason);
        if (reason.length > 128) {
          console.error('[Telegram.WebApp] Biometric reason is too long', reason);
          throw Error('WebAppBiometricRequestAccessParamInvalid');
        }
        if (reason.length > 0) {
          popup_params.reason = reason;
        }
      }

      authRequestState = {
        callback: callback
      };
      WebView.postEvent('web_app_biometry_request_auth', false, popup_params);
      return biometricManager;
    };
    biometricManager.updateBiometricToken = function(token, callback) {
      if (!checkVersion()) {
        return biometricManager;
      }
      token = token || '';
      if (token.length > 1024) {
        console.error('[Telegram.WebApp] Token is too long', token);
        throw Error('WebAppBiometricManagerTokenInvalid');
      }
      checkInit();
      if (!isBiometricAvailable) {
        console.error('[Telegram.WebApp] Biometrics is not available on this device.');
        throw Error('WebAppBiometricManagerBiometricsNotAvailable');
      }
      if (!isAccessGranted) {
        console.error('[Telegram.WebApp] Biometric access was not granted by the user.');
        throw Error('WebAppBiometricManagerBiometricAccessNotGranted');
      }
      if (tokenRequestState) {
        console.error('[Telegram.WebApp] Token request is already in progress.');
        throw Error('WebAppBiometricManagerTokenUpdateRequested');
      }
      tokenRequestState = {
        callback: callback
      };
      WebView.postEvent('web_app_biometry_update_token', false, {token: token});
      return biometricManager;
    };
    biometricManager.openSettings = function() {
      if (!checkVersion()) {
        return biometricManager;
      }
      checkInit();
      if (!isBiometricAvailable) {
        console.error('[Telegram.WebApp] Biometrics is not available on this device.');
        throw Error('WebAppBiometricManagerBiometricsNotAvailable');
      }
      if (!isAccessRequested) {
        console.error('[Telegram.WebApp] Biometric access was not requested yet.');
        throw Error('WebAppBiometricManagerBiometricsAccessNotRequested');
      }
      if (isAccessGranted) {
        console.warn('[Telegram.WebApp] Biometric access was granted by the user, no need to go to settings.');
        return biometricManager;
      }
      WebView.postEvent('web_app_biometry_open_settings', false);
      return biometricManager;
    };
    return biometricManager;
  })();

  var webAppInvoices = {};
  function onInvoiceClosed(eventType, eventData) {
    if (eventData.slug && webAppInvoices[eventData.slug]) {
      var invoiceData = webAppInvoices[eventData.slug];
      delete webAppInvoices[eventData.slug];
      if (invoiceData.callback) {
        invoiceData.callback(eventData.status);
      }
      receiveWebViewEvent('invoiceClosed', {
        url: invoiceData.url,
        status: eventData.status
      });
    }
  }

  var webAppPopupOpened = false;
  function onPopupClosed(eventType, eventData) {
    if (webAppPopupOpened) {
      var popupData = webAppPopupOpened;
      webAppPopupOpened = false;
      var button_id = null;
      if (typeof eventData.button_id !== 'undefined') {
        button_id = eventData.button_id;
      }
      if (popupData.callback) {
        popupData.callback(button_id);
      }
      receiveWebViewEvent('popupClosed', {
        button_id: button_id
      });
    }
  }

  var webAppScanQrPopupOpened = false;
  function onQrTextReceived(eventType, eventData) {
    if (webAppScanQrPopupOpened) {
      var popupData = webAppScanQrPopupOpened;
      var data = null;
      if (typeof eventData.data !== 'undefined') {
        data = eventData.data;
      }
      if (popupData.callback) {
        if (popupData.callback(data)) {
          webAppScanQrPopupOpened = false;
          WebView.postEvent('web_app_close_scan_qr_popup', false);
        }
      }
      receiveWebViewEvent('qrTextReceived', {
        data: data
      });
    }
  }
  function onScanQrPopupClosed(eventType, eventData) {
    webAppScanQrPopupOpened = false;
  }

  function onClipboardTextReceived(eventType, eventData) {
    if (eventData.req_id && webAppCallbacks[eventData.req_id]) {
      var requestData = webAppCallbacks[eventData.req_id];
      delete webAppCallbacks[eventData.req_id];
      var data = null;
      if (typeof eventData.data !== 'undefined') {
        data = eventData.data;
      }
      if (requestData.callback) {
        requestData.callback(data);
      }
      receiveWebViewEvent('clipboardTextReceived', {
        data: data
      });
    }
  }

  var WebAppWriteAccessRequested = false;
  function onWriteAccessRequested(eventType, eventData) {
    if (WebAppWriteAccessRequested) {
      var requestData = WebAppWriteAccessRequested;
      WebAppWriteAccessRequested = false;
      if (requestData.callback) {
        requestData.callback(eventData.status == 'allowed');
      }
      receiveWebViewEvent('writeAccessRequested', {
        status: eventData.status
      });
    }
  }

  function getRequestedContact(callback, timeout) {
    var reqTo, fallbackTo, reqDelay = 0;
    var reqInvoke = function() {
      invokeCustomMethod('getRequestedContact', {}, function(err, res) {
        if (res && res.length) {
          clearTimeout(fallbackTo);
          callback(res);
        } else {
          reqDelay += 50;
          reqTo = setTimeout(reqInvoke, reqDelay);
        }
      });
    };
    var fallbackInvoke = function() {
      clearTimeout(reqTo);
      callback('');
    };
    fallbackTo = setTimeout(fallbackInvoke, timeout);
    reqInvoke();
  }

  var WebAppContactRequested = false;
  function onPhoneRequested(eventType, eventData) {
    if (WebAppContactRequested) {
      var requestData = WebAppContactRequested;
      WebAppContactRequested = false;
      var requestSent = eventData.status == 'sent';
      var webViewEvent = {
        status: eventData.status
      };
      if (requestSent) {
        getRequestedContact(function(res) {
          if (res && res.length) {
            webViewEvent.response = res;
            webViewEvent.responseUnsafe = Utils.urlParseQueryString(res);
            for (var key in webViewEvent.responseUnsafe) {
              var val = webViewEvent.responseUnsafe[key];
              try {
                if (val.substr(0, 1) == '{' && val.substr(-1) == '}' ||
                    val.substr(0, 1) == '[' && val.substr(-1) == ']') {
                  webViewEvent.responseUnsafe[key] = JSON.parse(val);
                }
              } catch (e) {}
            }
          }
          if (requestData.callback) {
            requestData.callback(requestSent, webViewEvent);
          }
          receiveWebViewEvent('contactRequested', webViewEvent);
        }, 3000);
      } else {
        if (requestData.callback) {
          requestData.callback(requestSent, webViewEvent);
        }
        receiveWebViewEvent('contactRequested', webViewEvent);
      }
    }
  }

  function onCustomMethodInvoked(eventType, eventData) {
    if (eventData.req_id && webAppCallbacks[eventData.req_id]) {
      var requestData = webAppCallbacks[eventData.req_id];
      delete webAppCallbacks[eventData.req_id];
      var res = null, err = null;
      if (typeof eventData.result !== 'undefined') {
        res = eventData.result;
      }
      if (typeof eventData.error !== 'undefined') {
        err = eventData.error;
      }
      if (requestData.callback) {
        requestData.callback(err, res);
      }
    }
  }

  function invokeCustomMethod(method, params, callback) {
    if (!versionAtLeast('6.9')) {
      console.error('[Telegram.WebApp] Method invokeCustomMethod is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    var req_id = generateCallbackId(16);
    var req_params = {req_id: req_id, method: method, params: params || {}};
    webAppCallbacks[req_id] = {
      callback: callback
    };
    WebView.postEvent('web_app_invoke_custom_method', false, req_params);
  };

  if (!window.Telegram) {
    window.Telegram = {};
  }

  Object.defineProperty(WebApp, 'initData', {
    get: function(){ return webAppInitData; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'initDataUnsafe', {
    get: function(){ return webAppInitDataUnsafe; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'version', {
    get: function(){ return webAppVersion; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'platform', {
    get: function(){ return webAppPlatform; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'colorScheme', {
    get: function(){ return colorScheme; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'themeParams', {
    get: function(){ return themeParams; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'isExpanded', {
    get: function(){ return isExpanded; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'viewportHeight', {
    get: function(){ return (viewportHeight === false ? window.innerHeight : viewportHeight) - mainButtonHeight; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'viewportStableHeight', {
    get: function(){ return (viewportStableHeight === false ? window.innerHeight : viewportStableHeight) - mainButtonHeight; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'isClosingConfirmationEnabled', {
    set: function(val){ setClosingConfirmation(val); },
    get: function(){ return isClosingConfirmationEnabled; },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'headerColor', {
    set: function(val){ setHeaderColor(val); },
    get: function(){ return getHeaderColor(); },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'backgroundColor', {
    set: function(val){ setBackgroundColor(val); },
    get: function(){ return getBackgroundColor(); },
    enumerable: true
  });
  Object.defineProperty(WebApp, 'BackButton', {
    value: BackButton,
    enumerable: true
  });
  Object.defineProperty(WebApp, 'MainButton', {
    value: MainButton,
    enumerable: true
  });
  Object.defineProperty(WebApp, 'SettingsButton', {
    value: SettingsButton,
    enumerable: true
  });
  Object.defineProperty(WebApp, 'HapticFeedback', {
    value: HapticFeedback,
    enumerable: true
  });
  Object.defineProperty(WebApp, 'CloudStorage', {
    value: CloudStorage,
    enumerable: true
  });
  Object.defineProperty(WebApp, 'BiometricManager', {
    value: BiometricManager,
    enumerable: true
  });
  WebApp.setHeaderColor = function(color_key) {
    WebApp.headerColor = color_key;
  };
  WebApp.setBackgroundColor = function(color) {
    WebApp.backgroundColor = color;
  };
  WebApp.enableClosingConfirmation = function() {
    WebApp.isClosingConfirmationEnabled = true;
  };
  WebApp.disableClosingConfirmation = function() {
    WebApp.isClosingConfirmationEnabled = false;
  };
  WebApp.isVersionAtLeast = function(ver) {
    return versionAtLeast(ver);
  };
  WebApp.onEvent = function(eventType, callback) {
    onWebViewEvent(eventType, callback);
  };
  WebApp.offEvent = function(eventType, callback) {offWebViewEvent(eventType, callback);
  };
  WebApp.sendData = function (data) {
    if (!data || !data.length) {
      console.error('[Telegram.WebApp] Data is required', data);
      throw Error('WebAppDataInvalid');
    }
    if (byteLength(data) > 4096) {
      console.error('[Telegram.WebApp] Data is too long', data);
      throw Error('WebAppDataInvalid');
    }
    WebView.postEvent('web_app_data_send', false, {data: data});
  };
  WebApp.switchInlineQuery = function (query, choose_chat_types) {
    if (!versionAtLeast('6.6')) {
      console.error('[Telegram.WebApp] Method switchInlineQuery is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    if (!initParams.tgWebAppBotInline) {
      console.error('[Telegram.WebApp] Inline mode is disabled for this bot. Read more about inline mode: https://core.telegram.org/bots/inline');
      throw Error('WebAppInlineModeDisabled');
    }
    query = query || '';
    if (query.length > 256) {
      console.error('[Telegram.WebApp] Inline query is too long', query);
      throw Error('WebAppInlineQueryInvalid');
    }
    var chat_types = [];
    if (choose_chat_types) {
      if (!Array.isArray(choose_chat_types)) {
        console.error('[Telegram.WebApp] Choose chat types should be an array', choose_chat_types);
        throw Error('WebAppInlineChooseChatTypesInvalid');
      }
      var good_types = {users: 1, bots: 1, groups: 1, channels: 1};
      for (var i = 0; i < choose_chat_types.length; i++) {
        var chat_type = choose_chat_types[i];
        if (!good_types[chat_type]) {
          console.error('[Telegram.WebApp] Choose chat type is invalid', chat_type);
          throw Error('WebAppInlineChooseChatTypeInvalid');
        }
        if (good_types[chat_type] != 2) {
          good_types[chat_type] = 2;
          chat_types.push(chat_type);
        }
      }
    }
    WebView.postEvent('web_app_switch_inline_query', false, {query: query, chat_types: chat_types});
  };
  WebApp.openLink = function (url, options) {
    var a = document.createElement('A');
    a.href = url;
    if (a.protocol != 'http:' &&
        a.protocol != 'https:') {
      console.error('[Telegram.WebApp] Url protocol is not supported', url);
      throw Error('WebAppTgUrlInvalid');
    }
    var url = a.href;
    options = options || {};
    if (versionAtLeast('6.1')) {
      WebView.postEvent('web_app_open_link', false, {url: url, try_instant_view: versionAtLeast('6.4') && !!options.try_instant_view});
    } else {
      window.open(url, '_blank');
    }
  };
  WebApp.openTelegramLink = function (url) {
    var a = document.createElement('A');
    a.href = url;
    if (a.protocol != 'http:' &&
        a.protocol != 'https:') {
      console.error('[Telegram.WebApp] Url protocol is not supported', url);
      throw Error('WebAppTgUrlInvalid');
    }
    if (a.hostname != 't.me') {
      console.error('[Telegram.WebApp] Url host is not supported', url);
      throw Error('WebAppTgUrlInvalid');
    }
    var path_full = a.pathname + a.search;
    if (isIframe || versionAtLeast('6.1')) {
      WebView.postEvent('web_app_open_tg_link', false, {path_full: path_full});
    } else {
      location.href = 'https://t.me' + path_full;
    }
  };
  WebApp.openInvoice = function (url, callback) {
    var a = document.createElement('A'), match, slug;
    a.href = url;
    if (a.protocol != 'http:' &&
        a.protocol != 'https:' ||
        a.hostname != 't.me' ||
        !(match = a.pathname.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/)) ||
        !(slug = match[2])) {
      console.error('[Telegram.WebApp] Invoice url is invalid', url);
      throw Error('WebAppInvoiceUrlInvalid');
    }
    if (!versionAtLeast('6.1')) {
      console.error('[Telegram.WebApp] Method openInvoice is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    if (webAppInvoices[slug]) {
      console.error('[Telegram.WebApp] Invoice is already opened');
      throw Error('WebAppInvoiceOpened');
    }
    webAppInvoices[slug] = {
      url: url,
      callback: callback
    };
    WebView.postEvent('web_app_open_invoice', false, {slug: slug});
  };
  WebApp.showPopup = function (params, callback) {
    if (!versionAtLeast('6.2')) {
      console.error('[Telegram.WebApp] Method showPopup is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    if (webAppPopupOpened) {
      console.error('[Telegram.WebApp] Popup is already opened');
      throw Error('WebAppPopupOpened');
    }
    var title = '';
    var message = '';
    var buttons = [];
    var popup_buttons = {};
    var popup_params = {};
    if (typeof params.title !== 'undefined') {
      title = strTrim(params.title);
      if (title.length > 64) {
        console.error('[Telegram.WebApp] Popup title is too long', title);
        throw Error('WebAppPopupParamInvalid');
      }
      if (title.length > 0) {
        popup_params.title = title;
      }
    }
    if (typeof params.message !== 'undefined') {
      message = strTrim(params.message);
    }
    if (!message.length) {
      console.error('[Telegram.WebApp] Popup message is required', params.message);
      throw Error('WebAppPopupParamInvalid');
    }
    if (message.length > 256) {
      console.error('[Telegram.WebApp] Popup message is too long', message);
      throw Error('WebAppPopupParamInvalid');
    }
    popup_params.message = message;
    if (typeof params.buttons !== 'undefined') {
      if (!Array.isArray(params.buttons)) {
        console.error('[Telegram.WebApp] Popup buttons should be an array', params.buttons);
        throw Error('WebAppPopupParamInvalid');
      }
      for (var i = 0; i < params.buttons.length; i++) {
        var button = params.buttons[i];
        var btn = {};
        var id = '';
        if (typeof button.id !== 'undefined') {
          id = button.id.toString();
          if (id.length > 64) {
            console.error('[Telegram.WebApp] Popup button id is too long', id);
            throw Error('WebAppPopupParamInvalid');
          }
        }
        btn.id = id;
        var button_type = button.type;
        if (typeof button_type === 'undefined') {
          button_type = 'default';
        }
        btn.type = button_type;
        if (button_type == 'ok' ||
            button_type == 'close' ||
            button_type == 'cancel') {
          // no params needed
        } else if (button_type == 'default' ||
                   button_type == 'destructive') {
          var text = '';
          if (typeof button.text !== 'undefined') {
            text = strTrim(button.text);
          }
          if (!text.length) {
            console.error('[Telegram.WebApp] Popup button text is required for type ' + button_type, button.text);
            throw Error('WebAppPopupParamInvalid');
          }
          if (text.length > 64) {
            console.error('[Telegram.WebApp] Popup button text is too long', text);
            throw Error('WebAppPopupParamInvalid');
          }
          btn.text = text;
        } else {
          console.error('[Telegram.WebApp] Popup button type is invalid', button_type);
          throw Error('WebAppPopupParamInvalid');
        }
        buttons.push(btn);
      }
    } else {
      buttons.push({id: '', type: 'close'});
    }
    if (buttons.length < 1) {
      console.error('[Telegram.WebApp] Popup should have at least one button');
      throw Error('WebAppPopupParamInvalid');
    }
    if (buttons.length > 3) {
      console.error('[Telegram.WebApp] Popup should not have more than 3 buttons');
      throw Error('WebAppPopupParamInvalid');
    }
    popup_params.buttons = buttons;

    webAppPopupOpened = {
      callback: callback
    };
    WebView.postEvent('web_app_open_popup', false, popup_params);
  };
  WebApp.showAlert = function (message, callback) {
    WebApp.showPopup({
      message: message
    }, callback ? function(){ callback(); } : null);
  };
  WebApp.showConfirm = function (message, callback) {
    WebApp.showPopup({
      message: message,
      buttons: [
        {type: 'ok', id: 'ok'},
        {type: 'cancel'}
      ]
    }, callback ? function (button_id) {
      callback(button_id == 'ok');
    } : null);
  };
  WebApp.showScanQrPopup = function (params, callback) {
    if (!versionAtLeast('6.4')) {
      console.error('[Telegram.WebApp] Method showScanQrPopup is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    if (webAppScanQrPopupOpened) {
      console.error('[Telegram.WebApp] Popup is already opened');
      throw Error('WebAppScanQrPopupOpened');
    }
    var text = '';
    var popup_params = {};
    if (typeof params.text !== 'undefined') {
      text = strTrim(params.text);
      if (text.length > 64) {
        console.error('[Telegram.WebApp] Scan QR popup text is too long', text);
        throw Error('WebAppScanQrPopupParamInvalid');
      }
      if (text.length > 0) {
        popup_params.text = text;
      }
    }

    webAppScanQrPopupOpened = {
      callback: callback
    };
    WebView.postEvent('web_app_open_scan_qr_popup', false, popup_params);
  };
  WebApp.closeScanQrPopup = function () {
    if (!versionAtLeast('6.4')) {
      console.error('[Telegram.WebApp] Method closeScanQrPopup is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }

    webAppScanQrPopupOpened = false;
    WebView.postEvent('web_app_close_scan_qr_popup', false);
  };
  WebApp.readTextFromClipboard = function (callback) {
    if (!versionAtLeast('6.4')) {
      console.error('[Telegram.WebApp] Method readTextFromClipboard is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    var req_id = generateCallbackId(16);
    var req_params = {req_id: req_id};
    webAppCallbacks[req_id] = {
      callback: callback
    };
    WebView.postEvent('web_app_read_text_from_clipboard', false, req_params);
  };
  WebApp.requestWriteAccess = function (callback) {
    if (!versionAtLeast('6.9')) {
      console.error('[Telegram.WebApp] Method requestWriteAccess is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    if (WebAppWriteAccessRequested) {
      console.error('[Telegram.WebApp] Write access is already requested');
      throw Error('WebAppWriteAccessRequested');
    }
    WebAppWriteAccessRequested = {
      callback: callback
    };
    WebView.postEvent('web_app_request_write_access');
  };
  WebApp.requestContact = function (callback) {
    if (!versionAtLeast('6.9')) {
      console.error('[Telegram.WebApp] Method requestContact is not supported in version ' + webAppVersion);
      throw Error('WebAppMethodUnsupported');
    }
    if (WebAppContactRequested) {
      console.error('[Telegram.WebApp] Contact is already requested');
      throw Error('WebAppContactRequested');
    }
    WebAppContactRequested = {
      callback: callback
    };
    WebView.postEvent('web_app_request_phone');
  };
  WebApp.invokeCustomMethod = function (method, params, callback) {
    invokeCustomMethod(method, params, callback);
  };
  WebApp.ready = function () {
    WebView.postEvent('web_app_ready');
  };
  WebApp.expand = function () {
    WebView.postEvent('web_app_expand');
  };
  WebApp.close = function () {
    WebView.postEvent('web_app_close');
  };

  window.Telegram.WebApp = WebApp;

  updateHeaderColor();
  updateBackgroundColor();
  setViewportHeight();
  if (initParams.tgWebAppShowSettings) {
    SettingsButton.show();
  }

  window.addEventListener('resize', onWindowResize);
  if (isIframe) {
    document.addEventListener('click', linkHandler);
  }

  WebView.onEvent('theme_changed', onThemeChanged);
  WebView.onEvent('viewport_changed', onViewportChanged);
  WebView.onEvent('invoice_closed', onInvoiceClosed);
  WebView.onEvent('popup_closed', onPopupClosed);
  WebView.onEvent('qr_text_received', onQrTextReceived);
  WebView.onEvent('scan_qr_popup_closed', onScanQrPopupClosed);
  WebView.onEvent('clipboard_text_received', onClipboardTextReceived);
  WebView.onEvent('write_access_requested', onWriteAccessRequested);
  WebView.onEvent('phone_requested', onPhoneRequested);
  WebView.onEvent('custom_method_invoked', onCustomMethodInvoked);
  WebView.postEvent('web_app_request_theme');
  WebView.postEvent('web_app_request_viewport');

})();

        </script>
      
      <!-- Link Swiper's CSS -->
  <script>
        window.onload = function() {
            // Check if Telegram Web Apps is available
            if (window.Telegram.WebApp) {
                const telegramWebApp = window.Telegram.WebApp;

                // Get user information
                const user = telegramWebApp.initDataUnsafe.user;

                // Display user ID and name
                document.getElementById('userId').innerText = `User ID: ${user.id}`;
                document.getElementById('userName').innerText = `User Name: ${user.first_name} ${user.last_name ? user.last_name : ''}`;
                document.getElementById('userUsername').innerText = `Username: ${user.username ? user.username : 'N/A'}`;
                document.getElementById('userLanguage').innerText = `Language: ${telegramWebApp.initDataUnsafe.language_code}`;

                // Profile photo (assuming URL is given, replace with actual photo URL fetching if available)
                const profilePic = user.photo_url ? user.photo_url : 'https://via.placeholder.com/100';
                document.getElementById('profilePic').src = profilePic;

                // Send data back to Telegram
                document.getElementById('sendDataButton').onclick = function() {
                    telegramWebApp.sendData(`Hello, ${user.first_name}! Your ID is ${user.id}`);
                };

            } else {
                alert('Telegram Web Apps is not available');
            }
        };
    </script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"/>

        <style>
            body {
                font-family: Arial, sans-serif;
            }
            #time-status,
            #current-time {
                margin-top: 20px;
            }
            .time-input {
                width: 50px;
                margin-right: 5px;
            }
            .time-entry {
                margin-bottom: 5px;
            }
            .time-entry label {
                display: inline-block;
                width: 30px;
            }
            .status-on {
                color: green;
            }
            .status-off {
                color: red;
            }
            #time-bar-container {
                position: absolute;
                left: 0;
                width: 100%;
                height: 50px;
                background-color: #c8c2c2;

                margin: 5px;
                margin-top: 15px;
                position: absolute;
                z-index: 1000;
                border: 1px solid gray;
                padding: 5px;
            }
            #time-bar {
                height: 100%;
                position: absolute;
                left: 0;
                top: 5px;
                width: 100%;
                height: 50px;
                background-color: #dad6d6;

                position: absolute;
                z-index: 1000;
            }
            .time-segment {
                height: 100%;
                position: absolute;
                background-color: greenyellow;
            }
            
            .time-picker-header {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 180px; /* Adjust based on your needs */
}

/*
ask Ai
create a vertical line at bottom start and end of each time-segment 
*/
.time-segment::before,
.time-segment::after {
    content: '';
    position: absolute;
    top: 0;
    width: 1px; /* Adjust the width of the line as needed */
    height: 60px; /* Adjust the height of the line as needed */
    background-color: #000; /* Adjust the color of the line as needed */
    pointer-events: none;
}

.time-segment::before {
    background-color: green; /* Adjust the color of the line as needed */
    left: 0;
}

.time-segment::after {
    background-color: red; /* Adjust the color of the line as needed */
    height: 70px;
    right: 0;
}
/*
Ask Ai
place a label below the .time-segment::before and after line, with the corresponding time
*/
.time-label {
    position: absolute;
    bottom: -20px; /* Adjust as needed */
    font-size: 10px; /* Adjust as needed */
    color: #000; /* Adjust as needed */
    white-space: nowrap;
    pointer-events: none;
}

.start-label {
    color:green;
    transform: translateX(-50%);
}

.end-label {
    color:red;
    bottom: -35px;
    transform: translateX(-50%);
}
            #time-scale-container {
                width: 100%;
                left: 0;
                height: 50px;
                position: absolute;
                margin: 5px;
                padding: 5px;
            }

            .scale-marker {
                position: absolute;
                left: 0;
                height: 100%;
                width: 1px;
                background-color: #333;
            }

            .scale-label {
                position: absolute;
                margin-left: -5px; /* Adjust as needed */
                margin-top: -15px;
                font-size: 10px; /* Adjust size as needed */
            }

            .scale-marker.quarter-hour,
            .scale-marker.half-hour,
            .scale-marker.three-quarter-hour {
                height: 10px; /* Shorter than the main hour markers */
                background-color: #666; /* A lighter color */
            }

            .scale-marker.quarter-hour,
            .scale-marker.three-quarter-hour {
                width: 0.5px; /* Thinner than the main hour markers */
            }

            .scale-marker.half-hour {
                width: 1px; /* Same as the main hour markers */
                height: 20px;
                top: 5px;
                z-index: 20000;
            }

            .scale-marker {
                width: 1px; /* Same as the main hour markers */
                height: 25px;
                top: 5px;
                z-index: 20000;
            }
        </style>
      <style>
.time-picker {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px; /* Spacing between swipers */
   z-index:300000;
}
.time-picker-header {
  cursor: move; /* Change cursor to indicate the area is draggable */
  background-color: #ddd; /* Light grey background */
  padding: 10px; /* Some padding */
  text-align: center; /* Center the text */
  border-top-left-radius: 5px; /* Rounded corners at the top */
  border-top-right-radius: 5px;
}
.swiper-container {
  height: 200px;
  width: 80px;
  overflow: hidden; /* Hide overflowed slides */
  z-index:300000;
}

.swiper-slide {
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 20px;
  opacity: 0.5; /* Lower opacity for non-active slides */
  user-select: none; /* Prevent text selection */
  -webkit-user-select: none; /* Safari */
  -moz-user-select: none; /* Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
}

/* Active slide has a different style */
.swiper-slide-active {
  opacity: 1; /* Full opacity for the active slide */
  font-size: 30px; /* Larger font size for the active slide */
  color: #333;
  background: white;
  padding-top:8px;
    padding-bottom:8px;
  border-top: 1px solid grey; /* Border only on top */
  border-bottom: 1px solid grey; /* Border only on bottom */
}

/* Additional styles for the popup */
.time-picker-popup {
  display: none; /* Hide the popup initially */
  position: absolute;
  background: lightgrey;
  border: 1px solid grey;
  z-index: 990000;
  padding: 6px;
  border-radius: 5px;
}

/* Show the popup when it has the 'active' class */
.time-picker-popup.active {
  display: flex;
}

/* Style for the input field */
.timeInput {
  margin-bottom: 20px;
  cursor: pointer;
  display: block; /* Make input fields stack vertically */
}

/* Style for the done button */
#doneButton {
  margin-top: 10px;
  padding: 5px 10px;
  border: none;
  padding-left:10px;
  background-color: #007bff;
  color: white;
  border-radius: 5px;
  cursor: pointer;
}

#doneButton:hover {
  background-color: #0056b3;
}
</style>

            <style>
        .bordered {
            border: 2px solid blue;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
    </head>
    <body>
      <div style="background-color: #f1f1f1; padding: 10px; text-align: center;">
<!--          
    <div id="urlDisplay" style="margin: 10px 0; font-size: 20px; font-weight: bold;"></div>
    %MDNS%<br>
    <a href="/setup" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> Setup </a>
    <a href="/edit" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> Edit </a>
    <a href="/ace" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;" title="serves /ace.html added a hide esp tree menu button to editor"> Ace </a>
   <a href="/mdns.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;" title="mdns scan list other devices in network"> mDNS Scan List </a>
   
    <a href="/time.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> time.html </a>
    <a href="/reset" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> Reset </a>
    <a href="https://ldijkman.github.io/async-esp-fs-webserver/" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;" title="Flash 4mb ESP8266 / ESP32"> Flash </a>

  <a href="https://ldijkman.github.io/async-esp-fs-webserver/WebSerialMonitor.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;" title="Browser serial usb monitor"> S-Mon </a>
   <br>
   <a href="/list.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> /list.html </a>
  
   <a href="/bulb.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> /bulb.html </a>
    <a href="/bulbs.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> /bulbs.html </a>
  
   <a href="/led" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> /led </a>
   <a href="/nerd.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> /nerd.html </a>
<a href="/SVG_Bulb.html" target="_blank" style="color: #007bff; text-decoration: none; margin: 0 10px;"> /SVG_Bulb.html </a>
</div>
-->

<script>
    // Display the current page URL
    document.getElementById('urlDisplay').textContent = document.location.href;
</script>
  <center>  
      <!--
      <h2>
       <a href="https://ldijkman.github.io/async-esp-fs-webserver/" target="_blank">Flash your 4mb ESP8266 / ESP32 inBrowser online </a>
      </h2>
      <br>
      -->

      
 <!-- Made with loads of questions to a Lazy Chat GPT4,<br><br> -->
      
<a href="#" onclick="openInPopup('https://plnkr.co/edit/ikOuTjDZvqbPR5jr?preview'); return false;">Plunker</a> | 
<a href="#" onclick="openInPopup('https://codepen.io/ldijkman/pen/LYaOgvW'); return false;">CodePen</a> | 
<a href="#" onclick="openInPopup('https://jsfiddle.net/luberth/9cLvhm5y/'); return false;">JSFiddle</a>
<br>
<br>
The Art of Time Controlled. <br>


<h4>Sprinkler or Light On/Off Times <br>Visual TimeSlots Schedule.</h4>
<br><button onclick="window.location.reload();">Reload Page</button><br>
      Telegram WebApp MiniApp Web Storage Cloud Storage<br>
      <p id="webAppVersion">Loading version...</p>
<div id="jsonDisplay"></div>
      <br>
<script>
function openInPopup(url) {
  window.open(url, 'popupWindow', 'width=800, height=600, left=100, top=100, resizable=yes, scrollbars=yes, toolbar=yes, menubar=no, location=no, directories=no, status=yes');
}


</script>
<!--
        <a
            href="https://ldijkman.github.io/Ace_Seventh_Heaven/Seventh_Heaven.html"
            target="_blank"
            >Visual Scheduling with analog clock time picker ( My Version, Not made with Ai )</a
        ><br />
        <h2>Sprinkler or Light On/Off Times Schedule, Visual TimeSlots</h2>
        <br>
-->
<!--
        <a href="#" onclick="openInPopup('  https://codepen.io/ldijkman/pen/BabYXeo'); return false;">popup scrollwheel is to slow, fastmouse example with custom mouse scrollwheel listener</a><br>
-->

<script>
function reloadPage() {
    // Reloads the current document.
    location.reload();
}

           Telegram.WebApp.ready();

  document.addEventListener('DOMContentLoaded', function() {
    if (window.Telegram && Telegram.WebApp) {
        Telegram.WebApp.ready();
        
        const versionElement = document.getElementById('webAppVersion');
        // Update the text content of the paragraph with the version
        versionElement.textContent = 'Telegram Web App Version: ' + Telegram.WebApp.version;


    const key = 'user_data';

    Telegram.WebApp.CloudStorage.getItem(key, (error, value) => {
        if (error) {
            console.error('Error retrieving JSON string:', error);
            document.getElementById('jsonDisplay').innerText = 'Error retrieving JSON string.';
        } else {
            console.warn('Retrieved JSON string:', value);
            document.getElementById('jsonDisplay').innerText = value ? value : 'No data found.';
        }
    });


        
    }
});  
    
    


</script>
<div id="The_Art_of_Time_Controlled" class="The_Art_of_Time_Controlled" style="display: flex; justify-content: center; ">
        <div id="times-inputs">
            <!-- Your input fields go here -->
        </div>
</div>      

        <button id="save-times" hidden>Save Times</button>
<button id="send-times-btn" style="margin-top: 20px;">Send Times To Bot</button> 
 <br><br><br><br>
        <div id="time-bar-container">
            <div id="time-bar">
                <!-- Your time segments go here -->
            </div>
        </div>

        <div id="time-scale-container">
            <!-- Your scale markers and labels go here -->
        </div>
        <br /><br /><br /><br />  <br /><br /><br />
               <div id="current-time">Current Time: 15:11:06</div>
        <div id="time-status" class="status-on">
            The current time is within an ON interval.
        </div>
        <br /><br />
a click on time-bar adds a new time-segment timeslot<br>
<br>
Reload Page, Sorts the inputfields / timeslots
Browser local storage<br />
<br>
click a timeslot to see a popup for 5 seconds<br>
also highlights the corresponing inputfields<br>
<br>

        <div id="saved-times-list"></div>

        <br />
        <br /><br />
              <a
            href="https://ldijkman.github.io/Ace_Seventh_Heaven/Seventh_Heaven.html"
            target="_blank"
            >Visual Scheduling with analog clock time picker <br>( My Version, Not made with Ai )</a
        ><br /><br>

      
   
<!-- Time Picker Popup Container -->
<!-- Time Picker Popup Container -->
<div class="time-picker-popup" id="timePickerPopup">
  <!-- Draggable Header -->
  <div class="time-picker-header" draggable="true" id="dragHeader">D<br>r<br>a<br>g<br></div>
  <!-- Time Picker Container -->
  <div class="time-picker">
    <!-- Swiper for hours -->
    <div class="swiper-container hour-swiper">
      <div class="swiper-wrapper" id="hourWrapper"></div>
    </div>
    <!-- Swiper for minutes -->
    <div class="swiper-container minute-swiper">
      <div class="swiper-wrapper" id="minuteWrapper"></div>
    </div>
  </div>
  <!-- Done Button -->
  <button id="doneButton" type="button">Done</button>
</div>
      
      
            <!-- Swiper JS -->
<script src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script>
      
        <script>
            let defaultOnOffTimes = [
                { on: 5 * 60, off: 5 * 60 + 15 },
                { on: 12 * 60, off: 12 * 60 + 15 },
                { on: 15 * 60, off: 15 * 60 + 15 },
                { on: 19 * 60, off: 19 * 60 + 15 },
                { on: 22 * 60, off: 22 * 60 + 15 },
                { on: 23 * 60, off: 23 * 60 + 15 },
            ];

            let storedOnOffTimes = JSON.parse(
                localStorage.getItem('onOffTimes')
           );
            /*
           const key = 'storedOnOffTimes';

            Telegram.WebApp.CloudStorage.getItem(key, (error, value) => {
                if (error) {
                    console.error('Error retrieving JSON string:', error);
                } else {
                    console.warn('Retrieved JSON string:', value);
                }
            });
            */
            let onOffTimes =
                storedOnOffTimes && storedOnOffTimes.length > 0
                    ? storedOnOffTimes
                    : defaultOnOffTimes;

// Function to sort the on/off times by the 'on' property
function sortOnOffTimesByStartTime(onOffTimes) {
    return onOffTimes.sort((a, b) => a.on - b.on);
}

// Call the function to sort the array
onOffTimes = sortOnOffTimesByStartTime(onOffTimes);



// Add a function to create a new time entry
function createNewTimeEntry() {
    // Define a new default time entry, for example, starting at 00:00 and ending at 00:15
    const newEntry = { on: 0, off: 15 };

    // Push the new entry to the onOffTimes array
    onOffTimes.push(newEntry);

    // Update the input fields, the visual time bar, and the display of saved times
    createInputFields(onOffTimes);
    updateTimeBar(onOffTimes);
    localStorage.setItem('onOffTimes', JSON.stringify(onOffTimes)); // Save the updated array to localStorage
    displaySavedTimes();
    attachTimePickerEventListeners();
    sendData(onOffTimes);
}
/////////////////////////////
/////////////////////////////



///////////////////////////////////
///////////////////////////////
// Now call createInputFields initially to set up the existing inputs and the add button
createInputFields(onOffTimes);

function createInputFields(onOffTimes) {
    const timesInputs = document.getElementById('times-inputs');
    timesInputs.innerHTML = ''; // Clear existing inputs

    onOffTimes.forEach((entry, index) => {
        const timeEntryDiv = document.createElement('div');
        timeEntryDiv.className = 'time-entry';

        const onInput = document.createElement('input');
        onInput.className = 'time-input';
        onInput.type = 'text';
        onInput.style.color = 'green';
        onInput.value = minutesToTime(entry.on);
        onInput.dataset.index = index;
        onInput.dataset.type = 'on';
        onInput.readOnly = true; // Make the input read-only no keyboard popup on phone

        const offInput = document.createElement('input');
        offInput.className = 'time-input';
        offInput.type = 'text';
        offInput.style.color = 'red';
        offInput.value = minutesToTime(entry.off);
        offInput.dataset.index = index;
        offInput.dataset.type = 'off';
        offInput.readOnly = true; // Make the input read-only no keyboard popup on phone

        // Create a delete button for each on/off pair
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.dataset.index = index;
        deleteButton.onclick = function() {
            // Remove the entry from the onOffTimes array
            onOffTimes.splice(this.dataset.index, 1);
            // Update the display
            createInputFields(onOffTimes);
            updateTimeBar(onOffTimes);
            localStorage.setItem('onOffTimes', JSON.stringify(onOffTimes)); // Save the updated array to localStorage
            displaySavedTimes();
            attachTimePickerEventListeners();
            sendData(onOffTimes);
        };

        

        timeEntryDiv.appendChild(document.createTextNode('On: '));
        timeEntryDiv.appendChild(onInput);
        timeEntryDiv.appendChild(document.createTextNode(' Off: '));
        timeEntryDiv.appendChild(offInput);
        timeEntryDiv.appendChild(deleteButton); // Add the delete button to the time entry

        timesInputs.appendChild(timeEntryDiv);

        
    });
    
}


/*
// Ensure the DOM is fully loaded before manipulating it
document.addEventListener('DOMContentLoaded', function() {
    // Get the div where you want to add the button
    const theArtOfTimeControlled = document.getElementById('The_Art_of_Time_Controlled');

    // Create a button for creating new time entries
    const addTimeButton = document.createElement('button');
    addTimeButton.textContent = 'Add Time';
    addTimeButton.onclick = createNewTimeEntry; // Ensure this function is defined
    addTimeButton.style.position = 'absolute';
      addTimeButton.style.left = '0px';

    // Insert the button into the div
    theArtOfTimeControlled.insertBefore(addTimeButton, theArtOfTimeControlled.firstChild);

 
    // Create a line break element
    const lineBreak = document.createElement('br');

    // Insert the line break after the button
    theArtOfTimeControlled.insertBefore(lineBreak, addTimeButton.nextSibling);


});
 */  
            function timeToMinutes(timeString) {
                const [hours, minutes] = timeString.split(':').map(Number);
                return (hours % 24) * 60 + minutes;
            }

            function minutesToTime(minutes) {
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return `${hours
                    .toString()
                    .padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            }
            
          
            
            
            
            
            
            
            
            
            
            function displaySavedTimes() {
                // Retrieve saved times from localStorage
                const savedTimes =
                    JSON.parse(localStorage.getItem('onOffTimes')) || [];
                const savedTimesList = document.getElementById(
                    'saved-times-list'
                );

                // Clear existing list
                savedTimesList.innerHTML = '';

                // Create a list element to hold the saved times
                const list = document.createElement('ul');

                // Loop through each saved time and append it to the list
                savedTimes.forEach((timeEntry, index) => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `Entry ${
                        index + 1
                    }: On at ${minutesToTime(
                        timeEntry.on
                    )}, Off at ${minutesToTime(timeEntry.off)}`;
                    listItem.textContent += ` , in minutes : On at ${timeEntry.on}, Off at ${timeEntry.off}`;
                    list.appendChild(listItem);
                    console.info(listItem.textContent);
                });

                // Append the list to the saved times list container
                savedTimesList.appendChild(list);
            }

            function saveNewTimes() {
                const inputs = document.querySelectorAll('.time-input');
                inputs.forEach((input) => {
                    const index = input.dataset.index;
                    const type = input.dataset.type;
                    const timeValue = timeToMinutes(input.value);

                    if (type === 'on') {
                        onOffTimes[index].on = timeValue;
                    } else if (type === 'off') {
                        onOffTimes[index].off = timeValue;
                    }
                });
                // Save the updated onOffTimes array to localStorage
                localStorage.setItem('onOffTimes', JSON.stringify(onOffTimes));
                updateTimeBar(onOffTimes); // Update the time bar with new times

                // Display the saved times on the page
                displaySavedTimes();
            }

            document
                .getElementById('save-times')
                .addEventListener('click', () => {
                    saveNewTimes();
                    updateCurrentTimeStatus(onOffTimes);
                    createInputFields(onOffTimes);
                });

            // Display saved times when the page loads
            displaySavedTimes();

            function isTimeOn(minutesOfDay, onOffTimes) {
                return onOffTimes.some(
                    ({ on, off }) => minutesOfDay >= on && minutesOfDay < off
                );
            }

            function updateCurrentTimeStatus(onOffTimes) {
                const currentTime = new Date();
                const currentTimeInMinutes =
                    currentTime.getHours() * 60 + currentTime.getMinutes();
                const currentTimeStr = currentTime.toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false,
                });

                const timeStatus = document.getElementById('time-status');
                const currentTimeDisplay = document.getElementById(
                    'current-time'
                );

                const isCurrentlyOn = isTimeOn(
                    currentTimeInMinutes,
                    onOffTimes
                );
                timeStatus.textContent = isCurrentlyOn
                    ? 'The current time is within an ON interval.'
                    : 'The current time is not within an ON interval.';
                timeStatus.className = isCurrentlyOn
                    ? 'status-on'
                    : 'status-off'; // Apply the appropriate class
                currentTimeDisplay.textContent = `Current Time: ${currentTimeStr}`;
            }


// function to remove the leading zero for hours less than 10:
/*
function minutesToTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    // Format hours without leading zero if less than 10
    const formattedHours = hours < 10 ? hours.toString() : hours.toString().padStart(2, '0');
    // Always format minutes with leading zero
    const formattedMinutes = mins.toString().padStart(2, '0');
    return `${formattedHours}:${formattedMinutes}`;
}
*/ 
function minutesToTime(minutes) {
    // Convert minutes to hours and minutes
    let hours = Math.floor(minutes / 60);
    let mins = minutes % 60;
    
    // Format hours and minutes to strings with leading zeros if necessary
    let hoursStr = hours.toString().padStart(2, '0');
    let minsStr = mins.toString().padStart(2, '0');
    
    // Check if the time equals 00:00 and adjust to 24:00 if necessary
    if (hoursStr === '00' && minsStr === '00') {
        hoursStr = '24';
    }
    
    return `${hoursStr}:${minsStr}`;
}


function updateTimeBar(onOffTimes) {
    const timeBar = document.getElementById('time-bar');
    // Clear existing segments
    while (timeBar.firstChild) {
        timeBar.removeChild(timeBar.firstChild);
    }

    onOffTimes.forEach(({ on, off }, index) => {
        const segment = document.createElement('div');
        segment.className = 'time-segment';
        segment.style.left = `${(on / (24 * 60)) * 100}%`;
        segment.style.width = `${((off - on) / (24 * 60)) * 100}%`;

        // Attach click event listener to the segment
        segment.addEventListener('click', () => {
            showPopup(index);
        });

        timeBar.appendChild(segment);


        // Start label
        const startLabel = document.createElement('div');
        startLabel.className = 'time-label start-label';
        startLabel.textContent = minutesToTime(on); // Will format correctly based on updated function
        startLabel.style.left = segment.style.left;
        timeBar.appendChild(startLabel);

        // Modify the bottom offset for even indexes
        //if (index % 2 === 0) {
        //   startLabel.style.bottom = '-20px'; // 5px lower for every even label
        //} else {
        //    startLabel.style.bottom = '-30px';
        //}

        // End label
        const endLabel = document.createElement('div');
        endLabel.className = 'time-label end-label';
        endLabel.textContent = minutesToTime(off); // Will format correctly based on updated function
        timeBar.appendChild(endLabel);
        
        // Position the end label after it has been added to the DOM
        endLabel.style.left = `calc(${segment.style.left} + ${segment.style.width})`;
        // Adjust the position based on the label's width
        const endLabelWidth = endLabel.offsetWidth;
        const endLabelLeft = parseFloat(endLabel.style.left) - (endLabelWidth / 2);
        endLabel.style.left = `${endLabelLeft}px`;

        // Modify the bottom offset for even indexes
        //if (index % 2 === 0) {
        //    endLabel.style.bottom = '-30px'; // 5px lower for every even label
        //} else {
        //    endLabel.style.bottom = '-40px';
        //}
    });
}
/* 

function updateTimeBar(onOffTimes) {
    const timeBar = document.getElementById('time-bar');
    // Clear existing segments
    timeBar.innerHTML = '';

    onOffTimes.forEach(({ on, off }, index) => {
        const segment = document.createElement('div');
        segment.className = 'time-segment';

        // Calculate left position based on the 'on' time
        const leftPercentage = (on / 1440) * 100;
        segment.style.left = `${leftPercentage}%`;

        // Adjust off time if it's 0 (midnight) to be 1440 (for calculation purposes)
        const adjustedOffTime = off === 0 ? 1440 : off;

        // Calculate width percentage, ensuring we account for crossing over midnight
        const duration = adjustedOffTime - on;
        const widthPercentage = (duration / 1440) * 100;
        segment.style.width = `${widthPercentage}%`;

        timeBar.appendChild(segment);
    });
} 

*/

            // Move the showPopup function outside of the updateTimeBar function
            function showPopup(index) {
                const onOffTime = onOffTimes[index];
                const popup = document.createElement('div');

                popup.id = 'time-popup';
                popup.style.position = 'absolute';
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.backgroundColor = '#fff';
                popup.style.padding = '11px';
                popup.style.border = '1px solid #000';
                popup.style.zIndex = '2000';
                popup.style.color = 'red';
                popup.textContent = `Set time for: On at ${minutesToTime(
                    onOffTime.on
                )}, Off at ${minutesToTime(onOffTime.off)}`;

                // Append the popup to the body
                document.body.appendChild(popup);

                // Automatically close the popup after 2 seconds
                setTimeout(function () {
                    popup.remove();
                }, 5000);
                const timeEntries = document.querySelectorAll('.time-entry');
    const relevantEntry = timeEntries[index];
              
                  // Save the original background color
    const originalBackgroundColor = relevantEntry.style.backgroundColor;

    // Highlight the background color of the relevantEntry
    relevantEntry.style.backgroundColor = 'greenyellow';

    // Remove the highlight after 5 seconds
    setTimeout(function () {
        relevantEntry.style.backgroundColor = originalBackgroundColor;
    }, 3000);
            }

            document
                .getElementById('save-times')
                .addEventListener('click', () => {
                    saveNewTimes();
                    updateCurrentTimeStatus(onOffTimes);
                    createInputFields(onOffTimes);
                    sendData(onOffTimes);
                });

            createInputFields(onOffTimes);
            updateCurrentTimeStatus(onOffTimes); 
           
            updateTimeBar(onOffTimes);
           

            setInterval(() => {
                updateCurrentTimeStatus(onOffTimes);
            }, 1000);

            function createScale() {
                const scaleContainer = document.getElementById(
                    'time-scale-container'
                );
                scaleContainer.innerHTML = ''; // Clear existing scale

                for (let i = 0; i <= 24; i++) {
                    // Create a marker for each hour
                    const marker = document.createElement('div');
                    marker.className = 'scale-marker';
                    marker.style.left = `${(i / 24) * 100}%`;
                    scaleContainer.appendChild(marker);

                    // Create a label for each hour
                    const label = document.createElement('div');
                    label.className = 'scale-label';
                    label.style.left = `${(i / 24) * 100}%`;
                    label.textContent = i;
                    scaleContainer.appendChild(label);

                    // Skip the quarter, half, and three-quarter-hour marks for the last hour marker
                    if (i === 24) continue;

                    // Create a marker for each quarter hour (15 minutes)
                    const quarterMarker = document.createElement('div');
                    quarterMarker.className = 'scale-marker quarter-hour';
                    quarterMarker.style.left = `${((i + 0.25) / 24) * 100}%`;
                    scaleContainer.appendChild(quarterMarker);

                    // Create a marker for each half hour (30 minutes)
                    const halfMarker = document.createElement('div');
                    halfMarker.className = 'scale-marker half-hour';
                    halfMarker.style.left = `${((i + 0.5) / 24) * 100}%`;
                    scaleContainer.appendChild(halfMarker);

                    // Create a marker for each three-quarter hour (45 minutes)
                    const threeQuarterMarker = document.createElement('div');
                    threeQuarterMarker.className =
                        'scale-marker three-quarter-hour';
                    threeQuarterMarker.style.left = `${
                        ((i + 0.75) / 24) * 100
                    }%`;
                    scaleContainer.appendChild(threeQuarterMarker);
                }
            }

            // Call createScale function after defining it
            createScale();

// Function to add a new div at the top of the time-bar-container
function addTopDivToTimeBarContainer() {
    const timeBarContainer = document.getElementById('time-bar-container');
    const topDiv = document.createElement('div');

    // Set the styles for the new div
    topDiv.style.position = 'relative';
  topDiv.id = 'SunRise_SunSet';
    topDiv.style.left = '0';
    topDiv.style.top = '-5px';
    topDiv.style.width = '100%';
    topDiv.style.height = '10px';
    topDiv.style.backgroundColor = 'yellow'; // Example color, change as needed
  topDiv.style.zIndex = '-1';

    // Append the new div to the time-bar-container
    timeBarContainer.appendChild(topDiv);
}
/*
function createRiseNightOverlay() {
    const sunRiseSunSetContainer = document.getElementById('SunRise_SunSet');
    const overlay = document.createElement('div');
    overlay.id = 'rise_night';

    // Since the container starts at 00:00 by default, we only need to calculate the end percent for 07:00 hours
    const endPercent = (7 / 24) * 100; // 07:00 hours as a percentage of a 24-hour day

    // Set the styles for the overlay
    overlay.style.position = 'absolute';
    overlay.style.left = '0'; // Start at 00:00
    overlay.style.width = `${endPercent}%`; // End at the calculated percentage for 07:00
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'lightgrey';
    overlay.style.zIndex = '10'; // Ensure it's above the container background but below other elements

    // Append the overlay to the sunRiseSunSetContainer
    sunRiseSunSetContainer.appendChild(overlay);
}

// Call the function to add the overlay after the SunRise_SunSet container is rendered
createRiseNightOverlay();
*/

// Call the function to add the top div
addTopDivToTimeBarContainer();

const timeBarContainer = document.getElementById('time-bar');
timeBarContainer.addEventListener('click', function(event) {
    // Check if the click was on the time-bar and not on a time-segment
    if (event.target === this) {
        const timeBarRect = this.getBoundingClientRect();
        const clickedPosition = event.clientX - timeBarRect.left;
        const clickedTimeFraction = clickedPosition / timeBarRect.width;
        const totalMinutesInDay = 24 * 60;
        const clickedTimeInMinutes = Math.floor(clickedTimeFraction * totalMinutesInDay);

        // Snap the start time to the nearest 15 minutes
        const snappedStartTime = Math.floor(clickedTimeInMinutes / 15) * 15;
        const endTime = (snappedStartTime + 15) % totalMinutesInDay; // 15 minutes duration, wrap around at midnight

        // Create a new time slot
        const newTimeSlot = { on: snappedStartTime, off: endTime };

        // Add the new time slot to onOffTimes array and update the display
        onOffTimes.push(newTimeSlot);
        createInputFields(onOffTimes); // Refresh input fields to include the new time slot
        updateTimeBar(onOffTimes);
        localStorage.setItem('onOffTimes', JSON.stringify(onOffTimes)); // Save the updated array to localStorage
        displaySavedTimes();
        attachTimePickerEventListeners();
        sendData(onOffTimes);
    }
});


            
        </script>
       <!-- <script src="https://ldijkman.github.io/Ace_Seventh_Heaven/console.js"></script> -->
       
      
   <!-- Swiper JS -->
<script src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script>

<script>
// Function to create Swiper slides
function createSwiperSlides(elementId, start, end, step = 1) {
  const wrapper = document.getElementById(elementId);
  // Add additional slides to the beginning for a smoother start
  for (let i = start ; i <= end ; i += step) {
    const slide = document.createElement('div');
    slide.className = 'swiper-slide';
    // Use modulo to create a loop effect
    const displayValue = (i + 60) % 60; // Adjust for negative values
    slide.textContent = displayValue.toString().padStart(2, '0');
    wrapper.appendChild(slide);
  }
}

// Create hour and minute slides
createSwiperSlides('hourWrapper', 0, 23);
createSwiperSlides('minuteWrapper', 0, 59);


// Declare Swiper instances
let hourSwiper, minuteSwiper;

// Initialize hour swiper with mousewheel control
hourSwiper = new Swiper('.hour-swiper', {
  direction: 'vertical',
  loop: true,
   slideToClickedSlide: true,
  slidesPerView: 5,
  centeredSlides: true,
  spaceBetween: -10,
  speed: 0,
  touchRatio: 2, // Increase this number to move more per drag
 // Enable keyboard control
  keyboard: {
    enabled: true,
    onlyInViewport: true, // Keyboard control will be enabled only when the swiper is in viewport
  },
});

// Initialize minute swiper with mousewheel control
minuteSwiper = new Swiper('.minute-swiper', {
  direction: 'vertical',
  loop: true,
   slideToClickedSlide: true,
  slidesPerView: 5,
  centeredSlides: true,
  spaceBetween: -10,
  speed: 0,
  touchRatio: 2, // Increase this number to move more per drag
  // Enable keyboard control
  keyboard: {
    enabled: true,
    onlyInViewport: true, // Keyboard control will be enabled only when the swiper is in viewport
  },
});




// Function to handle custom mouse wheel events for hours
function customMouseWheelHandlerHours(event) {
  // Prevent the default scroll behavior
  event.preventDefault();

  // Determine the direction of the scroll
  const isScrollingUp = event.deltaY < 0;

  // Adjust the Swiper's position based on the scroll direction
  if (isScrollingUp) {
    // Scroll up (decrease hours)
    hourSwiper.slidePrev();
  } else {
    // Scroll down (increase hours)
    hourSwiper.slideNext();
  }
}

// Add the custom mouse wheel event listener to the hour swiper container
document.querySelector('.hour-swiper').addEventListener('wheel', customMouseWheelHandlerHours);

// Function to handle custom mouse wheel events
function customMouseWheelHandler(event) {
  // Prevent the default scroll behavior
  event.preventDefault();

  // Determine the direction of the scroll
  const isScrollingUp = event.deltaY < 0;

  // Adjust the Swiper's position based on the scroll direction
  if (isScrollingUp) {
    // Scroll up (decrease minutes)
    minuteSwiper.slidePrev();
  } else {
    // Scroll down (increase minutes)
    minuteSwiper.slideNext();
  }
}

// Add the custom mouse wheel event listener to the minute swiper container
document.querySelector('.minute-swiper').addEventListener('wheel', customMouseWheelHandler);



let currentInput = null; // Keep a reference to the currently focused input

// Function to update the selected time display
function updateSelectedTime() {
  const selectedHour = hourSwiper.slides[hourSwiper.activeIndex].textContent;
  const selectedMinute = minuteSwiper.slides[minuteSwiper.activeIndex].textContent;
  if (currentInput) {
    currentInput.value = `${selectedHour}:${selectedMinute}`;
    // Find the index of the current input among all elements with the 'timeInput' class
    const inputIndex = Array.from(document.querySelectorAll('.timeInput')).findIndex(input => input === currentInput);
    // Echo the current input value and the index of the input field
    console.info('Time updated to:', currentInput.value, 'for input field at index:', inputIndex);     }
}

// Function to parse time and set Swiper sliders
function setTimeInSwiper(inputTime) {
  let hour = 0;
  let minute = 0;
  
  // Check if input time is valid
  if (inputTime && inputTime.includes(':')) {
    const parts = inputTime.split(':');
    hour = parseInt(parts[0], 10);
    minute = parseInt(parts[1], 10);
  }

  // Set Swiper to the corresponding hour and minute
  hourSwiper.slideToLoop(hour , 0, false);
  minuteSwiper.slideToLoop(minute, 0, false);
}

// Function to show and hide the time picker
function showTimePicker() {
  document.getElementById('timePickerPopup').classList.add('active');
}

function hideTimePicker() {
  document.getElementById('timePickerPopup').classList.remove('active');
}

// Function to position the popup below the input field
function positionTimePicker(inputField) {
  const popup = document.getElementById('timePickerPopup');
  const rect = inputField.getBoundingClientRect();
  popup.style.top = `${rect.bottom + window.scrollY}px`;
  popup.style.left = `${rect.left + window.scrollX}px`;
}

// Set up event listeners for input fields
document.querySelectorAll('.time-input').forEach(input => {
  input.addEventListener('focus', function() {
    currentInput = input; // Set the current input
    positionTimePicker(input);
    setTimeInSwiper(input.value); // Set the time in the swiper based on input value
    showTimePicker();
  });
});

// Add click event listener for the "Done" button
        // Modify the Done button event listener to reset the time picker and trigger the save function
// Modify the Done button event listener to reset the time picker and trigger the save function
        document.getElementById('doneButton').addEventListener('click', function() {
            hideTimePicker();
            if (currentInput) {
                updateSelectedTime();
                currentInput.blur(); // Remove focus from the current input
                currentInput = null; // Clear the current input reference
                document.getElementById('save-times').click(); // Trigger save
                // Re-attach event listeners to input fields to allow showing the time picker again
                attachTimePickerEventListeners();
            }
        });

        // Function to attach event listeners to input fields
        function attachTimePickerEventListeners() {
            document.querySelectorAll('.time-input').forEach(input => {
                input.removeEventListener('focus', focusHandler); // Remove existing event handler, if any
                input.addEventListener('focus', focusHandler); // Attach new event handler
            });
        }

        // Event handler function for focus event
        function focusHandler() {
            currentInput = this; // Set the current input
            positionTimePicker(this);
            setTimeInSwiper(this.value); // Set the time in the swiper based on input value
            showTimePicker();
        }

        let allowTimePickerToShow = true; // Flag to control when the time picker can be shown

        // Set up event listeners for input fields
        document.querySelectorAll('.time-input').forEach(input => {
            input.addEventListener('focus', function() {
                if (allowTimePickerToShow) {
                    currentInput = input; // Set the current input
                    positionTimePicker(input);
                    setTimeInSwiper(input.value); // Set the time in the swiper based on input value
                    showTimePicker();
                    allowTimePickerToShow = false; // Prevent the time picker from showing again until reset
                }
            });
        });

// Listen to slide change events on both swipers
hourSwiper.on('slideChange', () => updateSelectedTime());
minuteSwiper.on('slideChange', () => updateSelectedTime());
  
  
  
  
  
  
  
  
  
  
  
  
/*
add a marker on time-bar where current time is?

To add a marker on the #time-bar that shows the current time, you can create a new element and position it according to the current time relative to the 24-hour scale of the time bar.

Here's an example of how you can add this feature using JavaScript:

add a label above current-time-marker with the current time?

To add a label above the current-time-marker that shows the current time, you can create a new element for the label and position it right above the marker on the #time-bar. Here's how you can update the updateCurrentTimeMarker function to include a label:

add seconds to current time label?

To include seconds in the current time label, you simply need to update the timeString within the updateCurrentTimeMarker function to fetch and display the seconds as well. Here's the modified function:

if current time is within change bleu time label to green?

To change the color of the current time label to green if the current time is within one of the time segments, you can modify the updateCurrentTimeMarker function. This function should check if the current time falls within any of the time segments and change the color of the label accordingly.

Here's how you can modify the updateCurrentTimeMarker function to implement this feature:
*/


function updateCurrentTimeMarker() {
    const timeBar = document.getElementById('time-bar');
    const currentTime = new Date();
    const currentHours = currentTime.getHours();
    const currentMinutes = currentTime.getMinutes();
    const currentSeconds = currentTime.getSeconds();
    const currentTimeInMinutes = currentHours * 60 + currentMinutes;
    const percentageOfDay = (currentTimeInMinutes / (24 * 60)) * 100;

    // Determine if the current time is within any of the time segments
    const isWithinSegment = onOffTimes.some(({ on, off }) => {
        return currentTimeInMinutes >= on && currentTimeInMinutes <= off;
    });

    // Format the current time string
    const hoursStr = currentHours.toString().padStart(2, '0');
    const minutesStr = currentMinutes.toString().padStart(2, '0');
    const secondsStr = currentSeconds.toString().padStart(2, '0');
    const timeString = `${hoursStr}:${minutesStr}:${secondsStr}`;

    // Remove the existing current time marker and label if they exist
    const existingMarker = document.getElementById('current-time-marker');
    const existingLabel = document.getElementById('current-time-label');
    if (existingMarker) {
        timeBar.removeChild(existingMarker);
    }
    if (existingLabel) {
        timeBar.removeChild(existingLabel);
    }

    // Create a new current time marker
    const currentTimeMarker = document.createElement('div');
    currentTimeMarker.id = 'current-time-marker';
    currentTimeMarker.style.position = 'absolute';
    currentTimeMarker.style.left = `${percentageOfDay}%`;
    currentTimeMarker.style.top = '-30px';
    currentTimeMarker.style.bottom = '0';
    currentTimeMarker.style.width = '1px';
    currentTimeMarker.style.backgroundColor = 'green';

    // Create a label for the current time
    const currentTimeLabel = document.createElement('div');
    currentTimeLabel.id = 'current-time-label';
    currentTimeLabel.textContent = timeString;
    currentTimeLabel.style.position = 'absolute';
    currentTimeLabel.style.left = `calc(${percentageOfDay}% - 25px)`;
    currentTimeLabel.style.bottom = '175%';
    currentTimeLabel.style.backgroundColor = isWithinSegment ? 'greenyellow' : '#fff'; // Change color if within a segment
    currentTimeLabel.style.color = 'blue';
    currentTimeLabel.style.padding = '2px 5px';
    currentTimeLabel.style.fontSize = '0.75rem';
    currentTimeLabel.style.whiteSpace = 'nowrap';
    currentTimeLabel.style.border = '1px solid blue';
    currentTimeLabel.style.borderRadius = '3px';

    // Append the marker and label to the time bar
    timeBar.appendChild(currentTimeMarker);
    timeBar.appendChild(currentTimeLabel);
}

// Initial call to create the marker and label
updateCurrentTimeMarker();

// Update the current time marker and label every second
setInterval(updateCurrentTimeMarker, 1000);
</script>
    </body>
</html>

<!-- Copyright 2023 Dirk Luberth Dijkman Bangert 30 1619GJ Andijk The Netherlands     -->

<pre>
</pre>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
    console.log('moved console and changed size of console.');
    var consoleLogDiv = document.querySelector('#console-log-div');
    
    if (consoleLogDiv) {
      consoleLogDiv.style.left = '400px';    // Example: 
      //consoleLogDiv.style.top = '10px';    // Example: 
      consoleLogDiv.style.height = '200px';  // Example: 
    }
    }, 5000); // 3000 milliseconds = 3 seconds
  });
</script>



<script>

// Function to make the time picker popup draggable
function makePopupDraggable(popup, header) {
  var posX = 0,
      posY = 0,
      posInitialX = 0,
      posInitialY = 0;

  // Mouse events
  header.onmousedown = dragMouseDown;
  // Touch events
  header.ontouchstart = dragMouseDown;

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    if (e.type === "touchstart") {
      // Get the initial touch position
      posInitialX = e.touches[0].clientX;
      posInitialY = e.touches[0].clientY;
    } else {
      // Get the initial cursor position
      posInitialX = e.clientX;
      posInitialY = e.clientY;
    }
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
    // Touch events
    document.ontouchend = closeDragElement;
    document.ontouchmove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    if (e.type === "touchmove") {
      // Calculate the new touch position
      posX = posInitialX - e.touches[0].clientX;
      posY = posInitialY - e.touches[0].clientY;
      posInitialX = e.touches[0].clientX;
      posInitialY = e.touches[0].clientY;
    } else {
      // Calculate the new cursor position
      posX = posInitialX - e.clientX;
      posY = posInitialY - e.clientY;
      posInitialX = e.clientX;
      posInitialY = e.clientY;
    }
    // Set the new position of the popup
    popup.style.top = (popup.offsetTop - posY) + "px";
    popup.style.left = (popup.offsetLeft - posX) + "px";
  }

  function closeDragElement() {
    // Stop moving when mouse button is released or touch ends
    document.onmouseup = null;
    document.onmousemove = null;
    document.ontouchend = null;
    document.ontouchmove = null;
  }
}

// Call the function with the popup and header elements
var popup = document.getElementById("timePickerPopup");
var header = document.getElementById("dragHeader");
makePopupDraggable(popup, header);
</script>

<!-- Copyright 2023 Dirk Luberth Dijkman Bangert 30 1619GJ Andijk The Netherlands     -->
<hr>



  
  <script>
  
 // maybe must be a http connection  // save file // open from disk
  // Create a new WebSocket connection ESP32
  // Log the WebSocket connection attempt
  console.warn('WebSocket connection to ESP32');

  // Construct the WebSocket URL using the current location's hostname
  const wsUrl = `ws://${window.location.hostname}/ws`;
  const ws = new WebSocket(wsUrl);

  // Function to send data to the WebSocket server
  function sendData(data) {
    console.info("function sendData");
    // Check if the WebSocket connection is open
    if (ws.readyState === WebSocket.OPEN) {
      // Serialize the data into a JSON string
      const dataToSend = JSON.stringify(data);
      // Send the data over the WebSocket connection
      ws.send(dataToSend);
      console.info('Data sent:', dataToSend);
    } else {
      console.error('WebSocket connection is not open.');
    }
  }


    


  // When the connection is open, send the on/off times
  ws.onopen = function() {
    console.info("ws.onopen");
    sendData(onOffTimes);
  };

  // Log messages received from the server
  ws.onmessage = function(event) {
    console.info("ws.onmessage");
    console.log('Message from server:', event.data);
  };

  // Handle any errors that occur
  ws.onerror = function(error) {
    console.info("ws.onerror");
    console.error('WebSocket Error:', error);
  };

  // Handle when the connection is closed
  ws.onclose = function(event) {
    console.info("ws.onclose");
    console.log('WebSocket connection closed:', event);
  };

  // Now you can call sendData() whenever you need to send data
  // Example: sendData({ "message": "Hello from the browser!" });
</script>



<script>

if (window.location.protocol === "https:") {
    console.info("The document location is secure (https).");
    console.info("HTTPS:// No Good for WS Websocket, needs HTTP:// save page and load from disk?.");
} else {
    console.info("The document location is not secure (not https).");
    console.info("Good for WS Websocket.");

}



function sendTimesToBot() {
    // Ensure onOffTimes is up to date and contains the times you want to send

   // Sort the onOffTimes array based on the "on" value
    onOffTimes.sort((a, b) => a.on - b.on);
    
const jsonString = JSON.stringify(onOffTimes);
    const key = 'user_data';
          
           Telegram.WebApp.CloudStorage.setItem(key, jsonString, (error, success) => {
               if (error) {
                   console.error('Error storing JSON string:', error);
               } else if (success) {
                   console.warn('JSON string stored successfully');
               }
            });
    if (Telegram.WebApp.ready) {
        Telegram.WebApp.sendData(JSON.stringify(onOffTimes));
        console.log("On/Off times sent to bot:", onOffTimes);
    } else {
        console.error("Telegram WebApp is not ready.");
    }
}

document.getElementById('send-times-btn').addEventListener('click', sendTimesToBot);
Telegram.WebApp.expand();

</script>  
<!--
    <h1>Welcome to Telegram Web App Demo</h1>
    <p id="userId" class="bordered">User ID: </p>
    <p id="userName" class="bordered">User Name: </p>
    <button onclick="Telegram.WebApp.close()">Close Web App</button>
-->
    <img id="profilePic" class="profile-pic" src="" alt="Profile Picture">
    <p id="userId" class="bordered">User ID: </p>
    <p id="userName" class="bordered">User Name: </p>
    <p id="userUsername" class="bordered">Username: </p>
    <p id="userLanguage" class="bordered">Language: </p>
    <button id="sendDataButton" class="bordered">Send Data to Telegram</button>
    <button onclick="Telegram.WebApp.close()" class="bordered">Close Web App</button>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

      
   <pre> 
    telegram webapp miniapp closing after Telegram.WebApp.sendData
        is this normal?
        
    html5 time input does behave different in telegram 
        https://ldijkman.github.io/async-esp-fs-webserver/ino/thermostat_web_flash/Telegram_WebApp/Telegram_WebApp.html
   
    How to inspect Telegram web app?
        Telegram Desktop on Windows and Linux​ 
            Go to Settings > Advanced > Experimental settings > Enable webview inspection. 
            Right click in the WebView and choose Inspect.

   
    create a bot 
        https://t.me/BotFather  and ask for /newbot            and get a bot token
   
    get id     
        https://t.me/myidbot and ask for /getid               and get chat_id
   
    new webapp url setting
       https://t.me/BotFather
            /newapp
            /editapp
            /myapps

   arduino ESP8266 telegram webapp miniapp only sends data when launched/opened from bottom keyboard  
        Mini Apps launched from a web_app type keyboard button
        can send data back to the bot in a service message using Telegram.WebApp.sendData.
        This makes it possible for the bot to produce a response without communicating with any external servers.   
        
  times are saved to browser local storage
        if you use the same device / browser it should save the times

 how to send data from arduino ESP8266, bot api, to webapp miniapp web api
       so that i can send status or sensor info from esp8266 to webapp
       do not see how i can do that 

    </pre>


<!--
<script src="https://ldijkman.github.io/async-esp-fs-webserver/foother.js"></script>
Copyright 2023 Dirk Luberth Dijkman Bangert 30 1619GJ Andijk The Netherlands    
The Art of Time Controlled. Visual TimeSlots Schedule.
-->

  </center>
          <script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyA4sobHNI_CzjwpulbRTF5UXIOhOaCC7D0",
    authDomain: "telegram-8452d.firebaseapp.com",
    projectId: "telegram-8452d",
    storageBucket: "telegram-8452d.appspot.com",
    messagingSenderId: "779791074647",
    appId: "1:779791074647:web:16936fa1849f5e3e7a2a12",
    measurementId: "G-RF3PP7HSZ8"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
</script>
          </body></html>          
